<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html dir="ltr" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <meta content="Quantum computer,2001,2006,Advanced Encryption Standard,Almaden Research Center,America Online,Analog computer,Anyon,ArXiv,Asymmetric Algorithms,BPP" name="keywords" />
  <link href="../../favicon.ico" rel="shortcut icon" />
  <link href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm" rel="copyright" />
  <title>Quantum computer</title>
  <style media="screen,projection" type="text/css">/*<![CDATA[*/ @import "../../css/wp-monobook-main.css"; /*]]>*/</style>
  <link href="../../css/wp-commonPrint.css" media="print" rel="stylesheet" type="text/css" />
  <!--[if lt IE 5.5000]><style type="text/css">@import "../../css/IE50Fixes.css";</style><![endif]-->
  <!--[if IE 5.5000]><style type="text/css">@import "../../css/IE55Fixes.css";</style><![endif]-->
  <!--[if IE 6]><style type="text/css">@import "../../css/IE60Fixes.css";</style><![endif]-->
  <!--[if IE 7]><style type="text/css">@import "../../css/IE70Fixes.css";</style><![endif]-->
  <!--[if lt IE 7]><script type="text/javascript" src="../../js/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
  <script type="text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";

			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "Quantum_computer";
			var wgTitle = "Quantum computer";
			var wgArticleId = 25220;
			var wgCurRevisionId = 92178178;
			var wgIsArticle = true;
		
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
  <script src="../../js/wikibits.js" type="text/javascript"><!-- wikibits js --></script>
  <script src="../../js/wp.js" type="text/javascript"><!-- site js --></script>
  <style type="text/css">/*<![CDATA[*/
@import "../../css/wp-common.css";
@import "../../css/wp-monobook.css";
@import "../../css/wp.css";
/*]]>*/</style>
  <!-- Head Scripts -->
 </head>
 <body class="mediawiki ns-0 ltr page-Quantum_computer">
  <div id="globalWrapper">
   <div id="column-content">
    <div id="content"><a id="top" name="top"></a><h1 class="firstHeading">Quantum computer</h1>
     <div id="bodyContent">
      <h3 id="siteSub"><a href="../../index.htm">2007 Schools Wikipedia Selection</a>. Related subjects: <a href="../index/subject.IT.Computing_hardware_and_infrastructure.htm">Computing hardware and infrastructure</a></h3>
      <!-- start content -->
      <div class="thumb tright">
       <div style="width:182px;"><a class="internal" href="../../images/271/27182.png.htm" title="The Bloch sphere is a representation of a qubit, the fundamental building block of quantum computers."><img alt="The Bloch sphere is a representation of a qubit, the fundamental building block of quantum computers." height="177" longdesc="/wiki/Image:Blochsphere.svg" src="../../images/271/27182.png" width="180" /></a><div class="thumbcaption">
         <div class="magnify" style="float:right"><a class="internal" href="../../images/271/27182.png.htm" title="Enlarge"><img alt="Enlarge" height="11" src="../../images/0/1.png" width="15" /></a></div> The <!--del_lnk--> Bloch sphere is a representation of a <!--del_lnk--> qubit, the fundamental building block of quantum computers.</div>
       </div>
      </div>
      <p>A <b>quantum computer</b> is any device for <!--del_lnk--> computation that makes direct use of distinctively <!--del_lnk--> quantum mechanical phenomena, such as <!--del_lnk--> superposition and <!--del_lnk--> entanglement, to perform operations on data. In a classical (or conventional) computer, the amount of <!--del_lnk--> data is measured by bits; in a quantum computer, the data is measured by <!--del_lnk--> qubits. The basic principle of quantum computation is that the quantum properties of particles can be used to represent and structure data, and that quantum mechanisms can be devised and built to perform <!--del_lnk--> operations with these data.<p>Though quantum computing is still in its infancy, experiments have been carried out in which quantum computational operations were executed on a very small number of <!--del_lnk--> qubits. Research in both theoretical and practical areas continues at a frantic pace, and many national government and military funding agencies support quantum computing research to develop quantum computers for both civilian and national security purposes, such as <!--del_lnk--> cryptanalysis. (See <!--del_lnk--> Timeline of quantum computing for details on current and past progress.)<p>It is widely believed that if large-scale quantum computers can be built, they will be able to solve certain problems asymptotically faster than any classical computer. Quantum computers are different from other <a href="../../wp/c/Computer.htm" title="Computers">computers</a> such as <!--del_lnk--> DNA computers and computers based on <!--del_lnk--> transistors, even though these may ultimately use some kind of quantum mechanical effect (for example <!--del_lnk--> covalent bonds). Some computing architectures such as <!--del_lnk--> optical computers may use classical superposition of electromagnetic waves, but without some specifically quantum mechanical resource such as <!--del_lnk--> entanglement, they do not share the potential for computational speed-up of quantum computers.<p>
       <script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script><a id="The_basis_of_quantum_computing" name="The_basis_of_quantum_computing"></a><h2> <span class="mw-headline">The basis of quantum computing</span></h2>
      <div class="tright" style="border: solid #aaa 1px; margin: 0 0 1em 1em; font-size: 85%; line-height:1.5; background: #f9f9f9; width: 250px; padding: 4px; spacing: 0px; text-align: left;">
       <div style="float: right; margin-left:4px"><a class="image" href="../../images/35/3509.png.htm" title=""><img alt="" height="48" longdesc="/wiki/Image:Question_dropshade.svg" src="../../images/35/3509.png" width="40" /></a></div>
       <div><!--del_lnk--> Unsolved problems in physics: <i>Is it possible to construct a practical computer that performs <!--del_lnk--> calculations on <!--del_lnk--> qubits (quantum bits)?</i></div>
      </div>
      <p>In <a href="../../wp/q/Quantum_mechanics.htm" title="Quantum mechanics">quantum mechanics</a>, the state of a physical system (such as an <a href="../../wp/e/Electron.htm" title="Electron">electron</a> or a <a href="../../wp/p/Photon.htm" title="Photon">photon</a>) is described by a <!--del_lnk--> vector in a mathematical object called a <!--del_lnk--> Hilbert space. The realisation of the Hilbert space depends on the particular system. For instance, in the case of a single particle system in three dimensions, the state can be described by a complex-valued function defined on <b>R</b><sup>3</sup> (three-<!--del_lnk--> dimensional space) called a <!--del_lnk--> wave function. As described in the article on <a href="../../wp/q/Quantum_mechanics.htm" title="Quantum mechanics">quantum mechanics</a>, this function has a probabilistic interpretation; of particular significance is that <!--del_lnk--> quantum states can be in a <!--del_lnk--> superposition of the <!--del_lnk--> basis states. The <!--del_lnk--> time evolution of the system state vector is assumed to be <!--del_lnk--> unitary, meaning that it is reversible.<p>A classical computer has a memory made up of <!--del_lnk--> bits, where each bit holds either a one or a zero. The device computes by manipulating those bits, i.e. by transporting these bits from memory to (possibly a suite of) <!--del_lnk--> logic gates and back. A quantum computer maintains a vector of <!--del_lnk--> qubits. A qubit can hold a one, or a zero, or a superposition of these. A quantum computer operates by manipulating those qubits, i.e. by transporting these bits from memory to (possibly a suite of) <!--del_lnk--> quantum logic gates and back.<p>Qubits for a quantum computer can be implemented using particles with two <!--del_lnk--> spin states: &quot;up&quot; and &quot;down&quot; (typically written <img alt="|0\rangle" class="tex" src="../../images/350/35055.png" /> and <img alt="|1\rangle" class="tex" src="../../images/350/35056.png" />); in fact, any system possessing an <!--del_lnk--> observable quantity <i>A</i> which is <i>conserved</i> under time evolution and such that <i>A</i> has at least two discrete and sufficiently spaced consecutive <!--del_lnk--> eigenvalues, is a suitable candidate for implementing a qubit, since any such system can be mapped onto an effective <!--del_lnk--> spin-1/2.<p>For discussion of foundational aspects of quantum computing, see the article on <!--del_lnk--> quantum circuits.<p><a id="Bits_vs_qubits" name="Bits_vs_qubits"></a><h2> <span class="mw-headline">Bits vs qubits</span></h2>
      <p>Consider first a classical computer that operates on a 3 bit <!--del_lnk--> register. At any given time, the bits in the register are in a definite state, such as 101. In a quantum computer, however, the qubits can be in a <!--del_lnk--> superposition of all the classically allowed states. In fact, the register is described by a <!--del_lnk--> wavefunction:<dl>
       <dd><img alt="|\psi \rangle = \alpha|000\rangle + \beta|001\rangle + \gamma|010\rangle + \ldots" class="tex" src="../../images/350/35057.png" /></dl>
      <p>where the coefficients <span class="texhtml">&alpha;</span>, <span class="texhtml">&beta;</span>, <span class="texhtml">&gamma;</span>,... are <!--del_lnk--> complex numbers whose amplitudes squared are the probabilities to measure the qubits in each state. Consequently, <span class="texhtml">| &gamma; | <sup>2</sup></span> is the probability to measure the register in the state 010. That these numbers are complex is important because the <!--del_lnk--> phases of the numbers can constructively and destructively interfere with one another, an important feature for quantum algorithms.<p>For an <i>n</i> qubit <!--del_lnk--> quantum register, recording the state of the register requires 2<sup><i>n</i></sup> complex numbers (the 3-qubit register requires 2<sup>3</sup> = 8 numbers). Consequently, the number of classical states encoded in a quantum register grows exponentially with the number of qubits. For <i>n</i>=300, this is roughly 10<sup>90</sup>, more states than there are atoms in the <!--del_lnk--> known universe. Note that the coefficients are not all independent, since the probabilities must sum to 1. The representation is also (for most practical cases) non-unique, since there is no way to physically distinguish between a particular quantum register and a similar one where all of the amplitudes have been multiplied by the same <!--del_lnk--> phase such as &minus;1, <i>i</i>, or in general any number on the complex <!--del_lnk--> unit circle. One can show the <!--del_lnk--> dimension of the set of states of an <i>n</i> qubit register is 2<sup><i>n</i>+1</sup>&nbsp;&minus;&nbsp;2. See <!--del_lnk--> Bloch sphere.<p><a id="Initialization.2C_execution_and_termination" name="Initialization.2C_execution_and_termination"></a><h2> <span class="mw-headline">Initialization, execution and termination</span></h2>
      <p>In our example, the contents of the qubit registers can be thought of as an 8-dimensional complex <!--del_lnk--> vector. An algorithm for a quantum computer must initialize this vector in some specified form (dependent on the design of the quantum computer). In each step of the algorithm, that vector is modified by multiplying it by a <!--del_lnk--> unitary <a href="../../wp/m/Matrix_%2528mathematics%2529.htm" title="Matrix (mathematics)">matrix</a>. The matrix is determined by the physics of the device. The unitary character of the matrix ensures the matrix is invertible (so each step is reversible).<p>Upon termination of the algorithm, the 8-dimensional complex vector stored in the register must be somehow read off from the qubit register by a quantum <a href="../../wp/m/Measurement.htm" title="Measurement">measurement</a>. However, by the laws of quantum mechanics, that measurement will yield a <!--del_lnk--> random 3 bit string (and it will destroy the stored state as well). This random string can be used in computing the value of a function because (by design) the <!--del_lnk--> probability distribution of the measured output bitstring is skewed in favour of the correct value of the function. By repeated runs of the quantum computer and measurement of the output, the correct value can be determined, to a high probability, by majority polling of the outputs. See <!--del_lnk--> quantum circuit for a more precise formulation. In brief, quantum computations are probabilistic.<p>A quantum algorithm is implemented by an appropriate sequence of unitary operations. Note that for a given algorithm, the operations will always be done in exactly the same order. There is no &quot;IF THEN&quot; statement to vary the order, since there is no way to read the state of a qubit before the final measurement. There are, however, conditional gate operations such as the controlled NOT gate, or CNOT.<p>For more details on the sequences of operations used for various algorithms, see <!--del_lnk--> universal quantum computer, <!--del_lnk--> Shor&#39;s algorithm, <!--del_lnk--> Grover&#39;s algorithm, <!--del_lnk--> Deutsch-Jozsa algorithm, <!--del_lnk--> quantum Fourier transform, <!--del_lnk--> quantum gate, <!--del_lnk--> quantum adiabatic algorithm and <!--del_lnk--> quantum error correction. Also refer to the growing field of <!--del_lnk--> quantum programming.<p><a id="The_power_of_quantum_computers" name="The_power_of_quantum_computers"></a><h2> <span class="mw-headline">The power of quantum computers</span></h2>
      <p><!--del_lnk--> Integer factorization is believed to be computationally infeasible with an ordinary computer for large numbers that are the product of two <a href="../../wp/p/Prime_number.htm" title="Prime number">prime numbers</a> of roughly equal size (e.g., products of two 300-digit primes). By comparison, a quantum computer could solve this problem relatively easily. If a number has <i>n</i> bits (is <i>n</i> digits long when written in the <!--del_lnk--> binary numeral system), then a quantum computer with just over 2<i>n</i> qubits can use <!--del_lnk--> Shor&#39;s algorithm to find its factors. It can also solve a related problem called the <!--del_lnk--> discrete logarithm problem. This ability would allow a quantum computer to &quot;break&quot; many of the <a href="../../wp/c/Cryptography.htm" title="Cryptography">cryptographic</a> systems in use today, in the sense that there would be a relatively fast (<!--del_lnk--> polynomial time in <i>n</i>) algorithm for solving the problem. In particular, most of the popular <!--del_lnk--> public key ciphers could be much more quickly broken, including forms of <!--del_lnk--> RSA, <!--del_lnk--> ElGamal and <!--del_lnk--> Diffie-Hellman. These are used to protect secure Web pages, encrypted email, and many other types of data. Breaking these would have significant ramifications for electronic privacy and security. The only way to increase the security of an algorithm like <!--del_lnk--> RSA would be to increase the key size and hope that an adversary does not have the resources to build and use a powerful enough quantum computer. It seems plausible that it will always be possible to build classical computers that have more bits than the number of qubits in the largest quantum computer. If that&#39;s true, then algorithms like <!--del_lnk--> RSA could be made secure by ensuring that keylengths exceed the storage capacities of quantum computers.<p>There are some <!--del_lnk--> digital signature schemes that are believed to be secure against quantum computers. See for instance <!--del_lnk--> Lamport signatures.<p>Perhaps not as surprisingly, quantum computers could also be useful for running simulations of quantum mechanics. This idea goes back to <a href="../../wp/r/Richard_Feynman.htm" title="Richard Feynman">Richard Feynman</a> (1982) who observed that there is no known algorithm for simulating quantum systems on a classical computer and suggested to study the use of quantum computer for this purpose. The speedup achieved by quantum computers could be just as large as for factoring. This could be a great boon to <a href="../../wp/p/Physics.htm" title="Physics">physics</a>, <a href="../../wp/c/Chemistry.htm" title="Chemistry">chemistry</a>, <!--del_lnk--> materials science, <!--del_lnk--> nanotechnology, <a href="../../wp/b/Biology.htm" title="Biology">biology</a> and <a href="../../wp/m/Medicine.htm" title="Medicine">medicine</a>, all of which are limited today by the slow speed of quantum mechanical simulations. For example, some modern simulations that are taking IBM&#39;s <!--del_lnk--> Blue Gene <!--del_lnk--> supercomputer years, would take a quantum computer only a matter of seconds.<p>This dramatic advantage of quantum computers is currently known to exist for only those three problems: factoring, discrete logarithm, and quantum physics simulations. However, there is no proof that the advantage is real: an equally fast classical algorithm may still be discovered (though some consider this unlikely). There is one other problem where quantum computers have a smaller, though significant (quadratic) advantage. It is <i>quantum database search</i>, and can be solved by <!--del_lnk--> Grover&#39;s algorithm. In this case the advantage is provable. This establishes beyond doubt that (ideal) quantum computers are superior to classical computers for at least one problem.<p>Consider a problem that has these four properties:<ol>
       <li>The only way to solve it is to guess answers repeatedly and check them,<li>There are <i>n</i> possible answers to check,<li>Every possible answer takes the same amount of time to check, and<li>There are no clues about which answers might be better: generating possibilities randomly is just as good as checking them in some special order.</ol>
      <p>An example of this is a <!--del_lnk--> password cracker that attempts to guess the password for an <!--del_lnk--> encrypted file (assuming that the password has a maximum possible length).<p>For problems with all four properties, it will take an average of (<i>n</i>&nbsp;+&nbsp;1)/2 guesses to find the answer using a classical computer. The time for a quantum computer to solve this will be proportional to the square root of <i>n</i>. That can be a very large speedup, reducing some problems from years to seconds. It can be used to attack <!--del_lnk--> symmetric ciphers such as <!--del_lnk--> Triple DES and <!--del_lnk--> AES by attempting to guess the secret key. But it is also easy to defend against, by doubling the size of this key. There are also more complicated methods for secure communication, such as using <!--del_lnk--> quantum cryptography.<p>Regardless of whether any of these problems can be shown to have an advantage on a quantum computer, they nonetheless will always have the advantage of being an excellent tool for studying quantum mechanical interactions, which of itself is an enormous value to the scientific community.<p>There are currently no other practical problems known where quantum computers give a large speedup over classical computers. Research is continuing, and more problems may yet be found.<p><a id="Problems_and_practicality_issues" name="Problems_and_practicality_issues"></a><h2> <span class="mw-headline">Problems and practicality issues</span></h2>
      <p>There are a number of practical difficulties in building a quantum computer, and thus far quantum computers have only solved trivial problems. David DiVincenzo, of IBM, listed the following requirements for a practical quantum computer:<ul>
       <li>scalable physically to increase the number of qubits<li>qubits can be initialized to arbitrary values<li>quantum gates faster than decoherence time<li><!--del_lnk--> Turing-complete gate set<li>qubits can be read easily</ul>
      <p>To summarize the problem from the perspective of an engineer, one needs to solve the challenge of building a system which is isolated from everything <i>except</i> the measurement and manipulation mechanism. Furthermore, one needs to be able to turn off the coupling of the qubits to the measurement so as to not decohere the qubits while performing operations on them.<p><a id="Quantum_decoherence" name="Quantum_decoherence"></a><h3> <span class="mw-headline">Quantum decoherence</span></h3>
      <p>One major problem is keeping the components of the computer in a coherent state, as the slightest interaction with the external world would cause the system to <!--del_lnk--> decohere. This effect causes the unitary character (and more specifically, the invertibility) of quantum computational steps to be violated. Decoherence times for candidate systems, in particular the transverse relaxation time T<sub>2</sub> (terminology used in <!--del_lnk--> NMR and <!--del_lnk--> MRI technology, also called the <i>dephasing time</i>), typically range between nanoseconds and seconds at low temperature. The issue for optical approaches are more difficult as these timescales are orders of magnitude lower and an often cited approach to overcome it uses <!--del_lnk--> optical pulse shaping approach. Error rates are typically proportional to the ratio of operating time to decoherence time, hence any operation must be completed much quicker than the decoherence time. If the error rate is small enough, it is possible to use quantum error correction, which corrects errors due to decoherence, thereby allowing the total calculation time to be longer than the decoherence time. An often cited (but rather arbitrary) figure for required error rate in each gate is 10<sup>&minus;4</sup>. This implies that each gate must be able to perform its task 10,000 times faster than the decoherence time of the system.<p>Meeting this scalability condition is possible for a wide range of systems. However the use of error correction brings with it the cost of a greatly increased number of required qubits. The number required to factor integers using Shor&#39;s algorithm is still polynomial, and thought to be between <i>L</i><sup>4</sup> and <i>L</i><sup>6</sup>, where <i>L</i> is the number of bits in the number to be factored. For a 1000 bit number, this implies a need for 10<sup>12</sup> to 10<sup>18</sup> qubits. Fabrication and control of this large number of qubits is non-trivial for any of the proposed designs.<p>One approach to the stability-decoherence problem is to create a <!--del_lnk--> topological quantum computer with <!--del_lnk--> anyons, quasi-particles used as threads and relying on <!--del_lnk--> knot theory to form stable logic gates.<p><a id="Candidates" name="Candidates"></a><h3> <span class="mw-headline">Candidates</span></h3>
      <p>There are a number of quantum computing candidates, among those:<ol>
       <li><!--del_lnk--> Superconductor-based quantum computers (including <!--del_lnk--> SQUID-based quantum computers)<li><!--del_lnk--> Trapped ion quantum computer<li><!--del_lnk--> Electrons on helium quantum computers<li>&quot;<!--del_lnk--> Nuclear magnetic resonance on <!--del_lnk--> molecules in <!--del_lnk--> solution&quot;-based<li>&quot;<!--del_lnk--> Quantum dot on surface&quot;-based<li>&quot;<!--del_lnk--> Cavity quantum electrodynamics&quot; (<!--del_lnk--> CQED)-based<li>&quot;<!--del_lnk--> Molecular magnet&quot;-based<li><!--del_lnk--> Fullerene-based ESR quantum computer<li>Solid state NMR <!--del_lnk--> Kane quantum computers<li>Optic-based quantum computers (<!--del_lnk--> Quantum optics)<li><!--del_lnk--> Topological quantum computer</ol>
      <p>In 2005, researchers at the <!--del_lnk--> University of Michigan built a <!--del_lnk--> semiconductor chip which functioned as an <!--del_lnk--> ion trap. Such devices, produced by standard <!--del_lnk--> lithography techniques, may point the way to scalable quantum computing tools. An improved version was made in 2006.<p><a id="Quantum_computing_in_computational_complexity_theory" name="Quantum_computing_in_computational_complexity_theory"></a><h2> <span class="mw-headline">Quantum computing in computational complexity theory</span></h2>
      <p>This section surveys what is currently known mathematically about the power of quantum computers. It describes the known results from <!--del_lnk--> computational complexity theory and the <!--del_lnk--> theory of computation dealing with quantum computers.<p>The class of problems that can be efficiently solved by quantum computers is called <b><!--del_lnk--> BQP</b>, for &quot;bounded error, quantum, polynomial time&quot;. Quantum computers only run randomized algorithms, so <b>BQP</b> on quantum computers is the counterpart of <b><!--del_lnk--> BPP</b> on classical computers. It is defined as the set of problems solvable with a polynomial-time algorithm, whose probability of error is bounded away from one quarter (Nielsen &amp; Chuang 2000). A quantum computer is said to &quot;solve&quot; a problem if, for every instance, its answer will be right with high probability. If that solution runs in polynomial time, then that problem is in <b>BQP</b>.<p><b>BQP</b> is suspected to be disjoint from <!--del_lnk--> NP-complete and a strict superset of <b><!--del_lnk--> P</b>, but that is not known. Both <!--del_lnk--> integer factorization and <!--del_lnk--> discrete log are in <b>BQP</b>. Both of these problems are <b>NP</b> problems suspected to be outside <b>BPP</b>, and hence outside <b>P</b>. Both are suspected to not be <!--del_lnk--> NP-complete. There is a common misconception that quantum computers can solve NP-complete problems in polynomial time. That is not known to be true, and is generally suspected to be false.<p>An operator for a quantum computer can be thought of as changing a vector by multiplying it with a particular matrix. Multiplication by a matrix is a <!--del_lnk--> linear operation. It has been shown that if a quantum computer could be designed with <i>nonlinear</i> operators, then it could solve NP-complete problems in polynomial time. It could even do so for <!--del_lnk--> #P-complete problems. It is not yet known whether such a machine is possible.<p>Although quantum computers are sometimes faster than classical computers, ones of the types described above can&#39;t solve any problems that classical computers can&#39;t solve, given enough time and memory (albeit possibly an amount that could never practically be brought to bear). A <!--del_lnk--> Turing machine can simulate these quantum computers, so such a quantum computer could never solve an <!--del_lnk--> undecidable problem like the <!--del_lnk--> halting problem. The existence of &quot;standard&quot; quantum computers does not disprove the <!--del_lnk--> Church-Turing thesis (Nielsen and Chuang 2000).<p>Very recently, <!--del_lnk--> Debabrata Goswami and others have begun to investigate the possibility of using quantum mechanics for <!--del_lnk--> hypercomputation - that is, solving undecidable problems. Such claims have been met with very considerable skepticism as to whether it is even theoretically possible; see the <!--del_lnk--> hypercomputation article for more details.<p><a id="See_also" name="See_also"></a><div class="printfooter"> Retrieved from &quot;<!--del_lnk--> http://en.wikipedia.org/wiki/Quantum_computer&quot;</div>
      <!-- end content -->
      <div class="visualClear">
      </div>
     </div>
    </div>
   </div>
   <!-- end of the left (by default at least) column -->
   <div class="visualClear">
   </div>
   <div id="footer">
    <div class="center"> This reference article is mainly selected from the English Wikipedia with only minor checks and changes (see www.wikipedia.org for details of authors and sources) and is available under the <nobr><a href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm">GNU Free Documentation License</a></nobr>. See also our <b><a href="../../disclaimer.htm">Disclaimer</a></b>. </div>
   </div>
   <script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
  </div>
  
 </body>
</html>
