<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html dir="ltr" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <meta content="Multiple sequence alignment,Algorithm,Amino acid,Benchmark,Biological sequence,CASP,Caspase,Cladistics,Clustal,ClustalW,Clustering" name="keywords" />
  <link href="../../favicon.ico" rel="shortcut icon" />
  <link href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm" rel="copyright" />
  <title>Multiple sequence alignment</title>
  <style media="screen,projection" type="text/css">/*<![CDATA[*/ @import "../../css/wp-monobook-main.css"; /*]]>*/</style>
  <link href="../../css/wp-commonPrint.css" media="print" rel="stylesheet" type="text/css" />
  <!--[if lt IE 5.5000]><style type="text/css">@import "../../css/IE50Fixes.css";</style><![endif]-->
  <!--[if IE 5.5000]><style type="text/css">@import "../../css/IE55Fixes.css";</style><![endif]-->
  <!--[if IE 6]><style type="text/css">@import "../../css/IE60Fixes.css";</style><![endif]-->
  <!--[if IE 7]><style type="text/css">@import "../../css/IE70Fixes.css";</style><![endif]-->
  <!--[if lt IE 7]><script type="text/javascript" src="../../js/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
  <script type="text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";
                        
			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "Multiple_sequence_alignment";
			var wgTitle = "Multiple sequence alignment";
			var wgArticleId = 4066308;
			var wgIsArticle = true;
                        
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
  <script src="../../js/wikibits.js" type="text/javascript"><!-- wikibits js --></script>
  <script src="../../js/wp.js" type="text/javascript"><!-- site js --></script>
  <style type="text/css">/*<![CDATA[*/
@import "../../css/wp-common.css";
@import "../../css/wp-monobook.css";
@import "../../css/wp.css";
/*]]>*/</style>
  <!-- Head Scripts -->
 </head>
 <body class="mediawiki ns-0 ltr page-Multiple_sequence_alignment">
  <div id="globalWrapper">
   <div id="column-content">
    <div id="content"><a id="top" name="top"></a><h1 class="firstHeading">Multiple sequence alignment</h1>
     <div id="bodyContent">
      <h3 id="siteSub"><a href="../../index.htm">2007 Schools Wikipedia Selection</a>. Related subjects: <a href="../index/subject.Science.Biology.General_Biology.htm">General Biology</a></h3>
      <!-- start content -->
      <div class="thumb tright">
       <div style="width:302px;"><a class="internal" href="../../images/202/20273.gif.htm" title="First 90 positions of a protein multiple sequence alignment of instances of the acidic ribosomal protein P0 (L10E) from several organisms. Generated with ClustalW."><img alt="First 90 positions of a protein multiple sequence alignment of instances of the acidic ribosomal protein P0 (L10E) from several organisms. Generated with ClustalW." height="169" longdesc="/wiki/Image:RPLP0_90_ClustalW_aln.gif" src="../../images/202/20273.gif" width="300" /></a><div class="thumbcaption">
         <div class="magnify" style="float:right"><a class="internal" href="../../images/202/20273.gif.htm" title="Enlarge"><img alt="Enlarge" height="11" src="../../images/0/1.png" width="15" /></a></div> First 90 positions of a protein multiple sequence alignment of instances of the acidic ribosomal protein P0 (L10E) from several organisms. Generated with <!--del_lnk--> ClustalW.</div>
       </div>
      </div>
      <p>A <b>multiple sequence alignment (MSA)</b> is a <a href="../../wp/s/Sequence_alignment.htm" title="Sequence alignment">sequence alignment</a> of three or more <!--del_lnk--> biological sequences, generally <a href="../../wp/p/Protein.htm" title="Protein">protein</a>, <a href="../../wp/d/DNA.htm" title="DNA">DNA</a>, or <!--del_lnk--> RNA. In general, the input set of query sequences are assumed to have an <a href="../../wp/e/Evolution.htm" title="Evolution">evolutionary</a> relationship by which they share a lineage and are descended from a common ancestor. From the resulting MSA, sequence <!--del_lnk--> homology can be inferred and <!--del_lnk--> phylogenetic analysis can be conducted to assess the sequences&#39; shared evolutionary origins. Visual depictions of the alignment as in the image at right illustrate <!--del_lnk--> mutation events such as point mutations (single <!--del_lnk--> amino acid or <!--del_lnk--> nucleotide changes) that appear as differing characters in a single alignment column, and insertion or deletion mutations (or <!--del_lnk--> indels) that appear as gaps in one or more of the sequences in the alignment. Multiple sequence alignment is often used to assess sequence <!--del_lnk--> conservation of <!--del_lnk--> protein domains, <!--del_lnk--> tertiary and <!--del_lnk--> secondary structures, and even individual amino acids or nucleotides.<p>Multiple sequence alignment also refers to the process of aligning such a sequence set. Because three or more sequences of biologically relevant length are nearly impossible to align by hand, computational <a href="../../wp/a/Algorithm.htm" title="Algorithm">algorithms</a> are used to produce and analyze the alignments. MSAs require more sophisticated methodologies than <a href="../../wp/s/Sequence_alignment.htm" title="Sequence alignment">pairwise alignment</a> because they are more computationally complex to produce. Most multiple sequence alignment programs use <!--del_lnk--> heuristic methods rather than <!--del_lnk--> global optimization because identifying the optimal alignment between more than a few sequences of moderate length is prohibitively computationally expensive.<p>
       <script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script><a id="Dynamic_programming_and_computational_complexity" name="Dynamic_programming_and_computational_complexity"></a><h2> <span class="mw-headline">Dynamic programming and computational complexity</span></h2>
      <p>The most direct method for producing an MSA uses the <!--del_lnk--> dynamic programming technique to identify the globally optimal alignment solution. For proteins, this method usually involves two sets of parameters: a <!--del_lnk--> gap penalty and a <!--del_lnk--> substitution matrix assigning scores or probabilities to the alignment of each possible pair of amino acids based on the similarity of the amino acids&#39; chemical properties and the evolutionary probability of the mutation. For nucleotide sequences a substitution matrix can be used, but since there are only four possible standard characters per sequence and the individual nucleotides do not typically differ much in substitution probability, the parameters for DNA and RNA sequences usually consist of a gap penalty, a positive score for character matches, and a negative score for mismatches.<p>For <i>n</i> individual sequences, the method requires constructing the <i>n</i>-dimensional equivalent of the matrix formed in standard pairwise dynamic programming. The search space thus increases exponentially with increasing <i>n</i> and is also strongly dependent on sequence length. To find the global optimum for <i>n</i> sequences this way has been shown to be an <!--del_lnk--> NP-complete problem. Methods to reduce the search space by first performing pairwise dynamic programming on each pair of sequences in the query set and searching only the solution space near these results (effectively finding the intersection between local paths immediately surrounding each pairwise optimum solution) render the dynamic programming technique more efficient. The so-called &quot;sum of pairs&quot; method has been implemented in the software package <!--del_lnk--> MSA, but it is still impractical for many MSA applications that require the simultaneous alignment of dozens or even a few hundred sequences. Dynamic programming methods are now used only when an extremely high-quality alignment of a small number of sequences is needed, and as a <!--del_lnk--> benchmarking standard in evaluating new or refined heuristic techniques.<p><a id="Progressive_alignment_construction" name="Progressive_alignment_construction"></a><h2> <span class="mw-headline">Progressive alignment construction</span></h2>
      <p>One method of performing a heuristic alignment search is the progressive technique (also known as the hierarchical or tree method) that builds up a final MSA by first performing a series of pairwise alignments on successively less closely related sequences. Such methods begin by aligning the two most closely related sequences first and then successively aligning the next most closely related sequence in the query set to the alignment produced in the previous step. The initial &quot;most related&quot; pair is determined by an efficient <!--del_lnk--> clustering method such as <!--del_lnk--> neighbour-joining based on a simple heuristic search of the query set with a tool like <!--del_lnk--> FASTA. Progressive techniques therefore automatically construct a <!--del_lnk--> phylogenetic tree as well as an alignment.<p>One major limitation of progressive methods is their heavy dependence on the initial assignment of relatedness and on the quality of the initial alignment. The methods are thus sensitive as well to the distribution of sequences in the query set; performance improves when relatedness among query sequences is a relatively smooth gradient rather than distantly separated clusters. Performance also degrades significantly when all of the sequences in the set are rather distantly related, because inaccuracies in the initial alignment are then more likely. Most modern progressive methods modify their scoring function with a secondary weighting function that assigns scaling factors to individual members of the query set in a nonlinear fashion based on their phylogenetic distance from their nearest neighbors. Judicious choice of weighting can aid in evaluating relatedness and mitigate the effects of relatively poor initial alignments early in the progression.<p>Progressive alignment methods are efficient enough to implement on a large scale for many sequences and are often run on publicly accessible web servers so users need not locally install the applications of interest. A very popular progressive alignment method is the <!--del_lnk--> Clustal family, especially the weighted variant ClustalW to which access is provided by a large number of web portals including <!--del_lnk--> GenomeNet, <!--del_lnk--> EBI, and <!--del_lnk--> EMBNet. Different portals or implementations can vary in user interface and make different parameters accessible to the user. Clustal is used extensively for phylogenetic tree construction and as input for <!--del_lnk--> protein structure prediction by homology modeling.<p>Another common progressive alignment method called <!--del_lnk--> T-Coffee is slower than Clustal and its derivatives but generally produces more accurate alignments for distantly related sequence sets. T-coffee uses the output from Clustal as well as another local alignment program LALIGN, which finds multiple reqions of local alignment between two sequences. The resulting alignment and phylogenetic tree are used as a guide to produce new and more accurate weighting factors.<p>Because progressive methods are heuristics that are not guaranteed to converge to a global optimum, alignment quality can be difficult to evaluate and their true biological significance can be obscure. A very recent semi-progressive method that improves alignment quality and does not use a lossy heuristic while still running in <!--del_lnk--> polynomial time has been implemented in the program <!--del_lnk--> PSAlign.<p><a id="Iterative_methods" name="Iterative_methods"></a><h2> <span class="mw-headline">Iterative methods</span></h2>
      <p>A set of methods to produce MSAs while reducing the errors inherent in progressive methods are classified as &quot;iterative&quot; because they work similarly to progressive methods but repeatedly realign the initial sequences as well as adding new sequences to the growing MSA. One reason progressive methods are so strongly dependent on a high-quality initial alignment is the fact that these alignments are always incorporated into the final result - that is, once a sequence has been aligned into the MSA, its alignment is not considered further. This approximation improves efficiency at the cost of accuracy. By contrast, iterative methods can return to previously calculated pairwise alignments or sub-MSAs incorporating subsets of the query sequence as a means of optimizing a general <!--del_lnk--> objective function such as finding a high-quality alignment score.<p>A variety of subtly different iteration methods have been implemented and made available in software packages; reviews and comparisons have been useful but generally refrain from choosing a &quot;best&quot; technique. The software package <!--del_lnk--> PRRN/PRRP uses a <!--del_lnk--> hill-climbing algorithm to optimize its MSA alignment score and iteratively corrects both alignment weights and locally divergent or &quot;gappy&quot; regions of the growing MSA. PRRP performs best when refining an alignment previously constructed by a faster method. The alignment of individual motifs is then achieved with a matrix representation similar to a dot-matrix plot in a pairwise alignment. An alternative method that uses fast local alignments as anchor points or &quot;seeds&quot; for a slower global-alignment procedure is implemented in the <!--del_lnk--> CHAOS/DIALIGN suite.<p>A third popular iteration-based method called <!--del_lnk--> MUSCLE (multiple sequence alignment by log-expectation) improves on progressive methods with a more accurate distance measure to assess the relatedness of two sequences. The distance measure is updated between iteration stages (although, in its original form, MUSCLE contained only 2-3 iterations depending on whether refinement was enabled).<p><a id="Hidden_Markov_models" name="Hidden_Markov_models"></a><h2> <span class="mw-headline">Hidden Markov models</span></h2>
      <p><!--del_lnk--> Hidden Markov models are probabilistic models that can assign likelihoods to all possible combinations of gaps, matches, and mismatches to determine the most likely MSA or set of possible MSAs. HMMs can produce a single highest-scoring output but can also generate a family of possible alignments that can then be evaluated for biological significance. Because HMMs are probablistics, they do not produce the same solution every time they are run on the same dataset; thus they cannot be guaranteed to converge to an optimal alignment. HMMs can produce both global and local alignments. Although HMM-based methods have been developed relatively recently, they offer significant improvements in computational speed, especially for sequences that contain overlapping regions.<p>Typical HMM-based methods work by representing an MSA as a form of <!--del_lnk--> directed acyclic graph known as a partial-order graph, which consists of a series of nodes representing possible entries in the columns of an MSA. In this representation a column that is absolutely conserved (that is, that all the sequences in the MSA share a particular character at a particular position) is coded as a single node with as many outgoing connections as there are possible characters in the next column of the alignment. In the terms of a typical hidden Markov model, the observed states are the individual alignment columns and the &quot;hidden&quot; states represent the presumed ancestral sequence from which the sequences in the query set are hypothesized to have descended. A efficient search variant of the dynamic programming method, known as the <!--del_lnk--> Viterbi algorithm, is generally used to successively align the growing MSA to the next sequence in the query set to produce a new MSA. This is distinct from progressive alignment methods because the alignment of prior sequences is updated at each new sequence addition. However, like progressive methods, this technique can be influenced by the order in which the sequences in the query set are integrated into the alignment, especially when the sequences are distantly related.<p>Several software programs are available in which variants of HMM-based methods have been implemented and which are noted for their scalability and efficiency, although properly using an HMM method is more complex than using more common progressive methods. The simplest is <!--del_lnk--> POA (Partial-Order Alignment); a similar but more generalized method is implemented in the package <!--del_lnk--> SAM (Sequence Alignment and Modeling System). SAM has been used as a source of alignments for <!--del_lnk--> protein structure prediction to participate in the <!--del_lnk--> CASP structure prediction experiment and to develop a database of predicted proteins in the <a href="../../wp/y/Yeast.htm" title="Yeast">yeast</a> species <!--del_lnk--> S. cerevisiae. HMM methods can also be used for database search with <!--del_lnk--> HMMer.<p><a id="Genetic_algorithms_and_simulated_annealing" name="Genetic_algorithms_and_simulated_annealing"></a><h2> <span class="mw-headline">Genetic algorithms and simulated annealing</span></h2>
      <p>Standard optimization techniques in computer science - both of which were inspired by, but do not directly reproduce, physical processes - have also been used in an attempt to more efficiently produce quality MSAs. On such technique, <!--del_lnk--> genetic algorithms, have been used for MSA production in an attempt to broadly simulate the hypothesized evolutionary process that gave rise to the divergence in the query set. The method works by breaking a series of possible MSAs into fragments and repeatedly rearranging those fragments with the introduction of gaps at varying positions. A general <!--del_lnk--> objective function is optimized during the simulation, most generally the &quot;sum of pairs&quot; maximization function introduced in dynamic programming-based MSA methods. A technique for protein sequences has been implemented in the software program SAGA (Sequence Alignment by Genetic Algorithm) and its equivalent in RNA is called RAGA.<p>The technique of <!--del_lnk--> simulated annealing, by which an existing MSA produced by another method is refined by a series of rearrangements designed to find more optimal regions of alignment space than the one the input alignment already occupies. Like the genetic algorithm method, simulated annealing maximizes an objective function like the sum-of-pairs function. Simulated annealing uses a metaphorical &quot;temperature factor&quot; that determines the rate at which rearrangements proceed and the likelihood of each rearrangement; typical usage alternates periods of high rearrangement rates with relatively low likelihood (to explore more distant regions of alignment space) with periods of lower rates and higher likelihoods to more thoroughly explore local minima near the newly &quot;colonized&quot; regions. This approach has been implemented in the program MSASA (Multiple Sequence Alignment by Simulated Annealing).<p><a id="Motif_finding" name="Motif_finding"></a><h2> <span class="mw-headline">Motif finding</span></h2>
      <div class="thumb tright">
       <div style="width:502px;"><a class="internal" href="../../images/202/20274.png.htm" title="Alignment of the seven Drosophila caspases colored by motifs as identified by MEME. When motif positions and sequence alignments are generated independently, they often correlate well but not perfectly, as in this example."><img alt="Alignment of the seven Drosophila caspases colored by motifs as identified by MEME. When motif positions and sequence alignments are generated independently, they often correlate well but not perfectly, as in this example." height="82" longdesc="/wiki/Image:Caspase-motif-alignment.png" src="../../images/202/20274.png" width="500" /></a><div class="thumbcaption">
         <div class="magnify" style="float:right"><a class="internal" href="../../images/202/20274.png.htm" title="Enlarge"><img alt="Enlarge" height="11" src="../../images/0/1.png" width="15" /></a></div> Alignment of the seven <!--del_lnk--> Drosophila <!--del_lnk--> caspases colored by motifs as identified by MEME. When motif positions and sequence alignments are generated independently, they often correlate well but not perfectly, as in this example.</div>
       </div>
      </div>
      <p>Motif finding, also known as profile analysis, is a method of locating <!--del_lnk--> sequence motifs in global MSAs that is both a means of producing a better MSA and a means of producing a scoring matrix for use in searching other sequences for similar motifs. A variety of methods for isolating the motifs have been developed, but all are based on identifying short highly conserved patterns within the larger alignment and constructing a matrix similar to a substitution matrix that reflects the amino acid or nucleotide composition of each position in the putative motif. The alignment can then be refined using these matrices. In standard profile analysis, the matrix includes entries for each possible character as well as entries for gaps. Alternatively, statistical pattern-finding algorithms can identify motifs as a precursor to an MSA rather than as a derivation. In many cases when the query set contains only a small number of sequences or contains only highly related sequences, <!--del_lnk--> pseudocounts are added to normalize the distribution reflected in the scoring matrix. In particular, this corrects zero-probability entries in the matrix to values that are small but nonzero.<p>Blocks analysis is a method of motif finding that restricts motifs to ungapped regions in the alignment. Blocks can be generated from an MSA or they can be extracted from unaligned sequences using a precalculated set of common motifs previously generated from known gene families. Block scoring generally relies on the spacing of high-frequency characters rather than on the calculation of an explicit substitution matrix. The <!--del_lnk--> BLOCKS server provides an interactive method to locate such motifs in unaligned sequences.<p>Statistical pattern-matching has been implemented using both the <!--del_lnk--> expectation-maximization algorithm and the <!--del_lnk--> Gibbs sampler. One of the most common motif-finding tools, known as MEME, uses expectation maximization and hidden Markov methods to generate motifs that are then used as search tools by its companion MAST in the combined suite <!--del_lnk--> MEME/MAST.<p><a id="See_also" name="See_also"></a><div class="printfooter"> Retrieved from &quot;<!--del_lnk--> http://en.wikipedia.org/wiki/Multiple_sequence_alignment&quot;</div>
      <!-- end content -->
      <div class="visualClear">
      </div>
     </div>
    </div>
   </div>
   <!-- end of the left (by default at least) column -->
   <div class="visualClear">
   </div>
   <div id="footer">
    <div class="center"> This reference article is mainly selected from the English Wikipedia with only minor checks and changes (see www.wikipedia.org for details of authors and sources) and is available under the <nobr><a href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm">GNU Free Documentation License</a></nobr>. See also our <b><a href="../../disclaimer.htm">Disclaimer</a></b>. </div>
   </div>
   <script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
  </div>
  
 </body>
</html>
