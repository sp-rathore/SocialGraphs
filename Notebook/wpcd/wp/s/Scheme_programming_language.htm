<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html dir="ltr" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <meta content="Scheme (programming language),Car.ogg,Cdr.ogg,2006,ALGOL,Actor model,Arithmetic-geometric mean,Array,Association list,Bigloo,Call-with-current-continuation" name="keywords" />
  <link href="../../favicon.ico" rel="shortcut icon" />
  <link href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm" rel="copyright" />
  <title>Scheme (programming language)</title>
  <style media="screen,projection" type="text/css">/*<![CDATA[*/ @import "../../css/wp-monobook-main.css"; /*]]>*/</style>
  <link href="../../css/wp-commonPrint.css" media="print" rel="stylesheet" type="text/css" />
  <!--[if lt IE 5.5000]><style type="text/css">@import "../../css/IE50Fixes.css";</style><![endif]-->
  <!--[if IE 5.5000]><style type="text/css">@import "../../css/IE55Fixes.css";</style><![endif]-->
  <!--[if IE 6]><style type="text/css">@import "../../css/IE60Fixes.css";</style><![endif]-->
  <!--[if IE 7]><style type="text/css">@import "../../css/IE70Fixes.css";</style><![endif]-->
  <!--[if lt IE 7]><script type="text/javascript" src="../../js/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
  <script type="text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";
                        
			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "Scheme_(programming_language)";
			var wgTitle = "Scheme (programming language)";
			var wgArticleId = 28119;
			var wgIsArticle = true;
                        
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
  <script src="../../js/wikibits.js" type="text/javascript"><!-- wikibits js --></script>
  <script src="../../js/wp.js" type="text/javascript"><!-- site js --></script>
  <style type="text/css">/*<![CDATA[*/
@import "../../css/wp-common.css";
@import "../../css/wp-monobook.css";
@import "../../css/wp.css";
/*]]>*/</style>
  <!-- Head Scripts -->
 </head>
 <body class="mediawiki ns-0 ltr page-Scheme_programming_language">
  <div id="globalWrapper">
   <div id="column-content">
    <div id="content"><a id="top" name="top"></a><h1 class="firstHeading">Scheme (programming language)</h1>
     <div id="bodyContent">
      <h3 id="siteSub"><a href="../../index.htm">2007 Schools Wikipedia Selection</a>. Related subjects: <a href="../index/subject.IT.Computer_Programming.htm">Computer Programming</a></h3>
      <!-- start content -->
      <table class="infobox" style="width: 23em; text-align: left;font-size: 90%">
       <caption><big><b>Scheme</b></big></caption>
       <tr>
        <td colspan="2" style="text-align: center;"><a class="image" href="../../images/214/21470.png.htm" title=""><img alt="" height="100" longdesc="/wiki/Image:Lambda_lc.svg" src="../../images/214/21470.png" width="100" /></a></td>
       </tr>
       <tr>
        <th><!--del_lnk--> Paradigm:</th>
        <td><!--del_lnk--> multi-paradigm: <!--del_lnk--> functional, <!--del_lnk--> procedural</td>
       </tr>
       <tr>
        <th>Appeared in:</th>
        <td>1970s</td>
       </tr>
       <tr>
        <th>Designed by:</th>
        <td><!--del_lnk--> Guy L. Steele and <!--del_lnk--> Gerald Jay Sussman</td>
       </tr>
       <tr>
        <th><!--del_lnk--> Typing discipline:</th>
        <td>strong, dynamic</td>
       </tr>
       <tr>
        <th>Major implementations:</th>
        <td><!--del_lnk--> PLT Scheme, <!--del_lnk--> MIT Scheme, <!--del_lnk--> Scheme48, <!--del_lnk--> Chicken, <!--del_lnk--> Gambit-C, <!--del_lnk--> Guile, <!--del_lnk--> Bigloo, <!--del_lnk--> Chez Scheme, <!--del_lnk--> STk, <!--del_lnk--> Larceny, <!--del_lnk--> SCM</td>
       </tr>
       <tr>
        <th>Dialects:</th>
        <td>many</td>
       </tr>
       <tr>
        <th>Influenced by:</th>
        <td><!--del_lnk--> Lisp, <!--del_lnk--> ALGOL</td>
       </tr>
       <tr>
        <th>Influenced:</th>
        <td><!--del_lnk--> Common Lisp, <!--del_lnk--> JavaScript, <!--del_lnk--> Ruby</td>
       </tr>
       <tr>
        <td>
        </td>
       </tr>
      </table>
      <p><b>Scheme</b> is a <!--del_lnk--> multi-paradigm programming language. It is a <!--del_lnk--> dialect of <!--del_lnk--> Lisp which supports <a href="../../wp/f/Functional_programming.htm" title="Functional programming">functional</a> and <!--del_lnk--> procedural programming. It was developed by <!--del_lnk--> Guy L. Steele and <!--del_lnk--> Gerald Jay Sussman in the 1970s. Scheme was introduced to the academic world via a series of papers now referred to as Sussman and Steele&#39;s <!--del_lnk--> Lambda Papers. There are two standards that define the Scheme language: the official <!--del_lnk--> IEEE standard, and a de facto standard called the <i>Revised<sup>n</sup> Report on the Algorithmic Language Scheme</i>, nearly always abbreviated R<i>n</i>RS, where <i>n</i> is the number of the revision. The current standard is <b>R5RS</b>, and <b>R6RS</b> is in development.<p>Scheme&#39;s philosophy is <!--del_lnk--> minimalist. Scheme provides as few primitive notions as possible, and, where practical, lets everything else be provided by <!--del_lnk--> programming libraries.<p>Scheme was the first dialect of Lisp to choose static (a.k.a. lexical) over dynamic variable <!--del_lnk--> scope. It was also one of the first programming languages to support first-class <!--del_lnk--> continuations.<p>
       <script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script><a id="Origin" name="Origin"></a><h2> <span class="mw-headline">Origin</span></h2>
      <p>Scheme started as an attempt to understand <!--del_lnk--> Carl Hewitt&#39;s <!--del_lnk--> Actor model. Scheme was originally called &quot;Schemer&quot;, in the tradition of other Lisp-derived languages like <!--del_lnk--> Planner or Conniver. The current name resulted from the authors&#39; use of the <!--del_lnk--> ITS operating system, which limited filenames to two components of at most six characters each. Currently, &quot;Schemer&quot; is commonly used to refer to a Scheme programmer.<p><a id="Future" name="Future"></a><h2> <span class="mw-headline">Future</span></h2>
      <p>A new language standardization process began at the 2003 Scheme workshop, with the goal of producing an <!--del_lnk--> R6RS standard in 2006. It breaks with the earlier RnRS approach of unanimity. R6RS will feature a standard module system; allowing a split between the core language and libraries.<p><a id="Distinguishing_features" name="Distinguishing_features"></a><h2> <span class="mw-headline">Distinguishing features</span></h2>
      <p>Scheme is a minimalist language. The current language standard is only 50 pages, including a denotational semantics for the language core. The next revision of the standard will be expanded  to describe several libraries.<p>Like all <!--del_lnk--> Lisp dialects, Scheme has little syntax. There are no <!--del_lnk--> operator precedence rules because <!--del_lnk--> fully nested and parenthesized notation is used for all compound forms.<p>Scheme&#39;s macro system allows the user to add new syntactic constructs to the language. It respects the lexical scoping of the rest of the language, which avoids common programming errors that can occur in the macro systems of other programming languages.<p>Procedures in Scheme are <!--del_lnk--> first-class values, which allows for <a href="../../wp/f/Functional_programming.htm" title="Functional programming">functional programming</a>.<p>Scheme&#39;s <code><!--del_lnk--> call-with-current-continuation</code> operator allows the user to create non-local control constructs that must be built into other languages, such as iterators, co-routines, and backtracking.<p><a id="Language_elements" name="Language_elements"></a><h2> <span class="mw-headline">Language elements</span></h2>
      <p><a id="Comments" name="Comments"></a><h3> <span class="mw-headline">Comments</span></h3>
      <p>Each comment is preceded by a <!--del_lnk--> semicolon (;) and extends for the rest of the line. Some implementations allow comments to span multiple lines by wrapping them with a #|...|# (possibly nested). Other implementations allow an entire <!--del_lnk--> s-expression to be commented out by prepending it with #;.<p><a id="Variables" name="Variables"></a><h3> <span class="mw-headline">Variables</span></h3>
      <p>Variables are dynamically typed. Variables are bound by a <i>define</i>, a <i>let</i> expression, and a few other Scheme forms. Variables bound at the top level with a define are in <i>global scope</i>.<pre>
 (define var1 value)
</pre><p>Variables bound in a let are in scope for the body of the let.<pre>
 (let ((var1 value))
   ...
   ; scope of var1
   ...)
</pre><p><a id="Functions" name="Functions"></a><h3> <span class="mw-headline">Functions</span></h3><pre>
1  (define fun
     (lambda (arg1 arg2)
       ...))
2  (define (fun arg1 arg2)
     ...)
3  (fun value1 value2)
4  (apply fun (list value1 value2))
</pre><p>Functions are first-class objects in Scheme. They can be arguments to other functions and be returned by them. They can be assigned to variables. For example a function with two arguments <i>arg1</i> and <i>arg2</i> is defined in line 1 and line 2 is an abbreviation of it. Line 3 shows how functions are applied. Note that the function being applied is in the first position of the list while the rest of the list contains the arguments. The apply function will take the first argument and apply it to a given list of arguments, so the previous function call can also be written as seen on line 4.<p>In Scheme, functions are divided into two basic categories: procedures and primitives. All primitives are procedures, but not all procedures are primitives. Primitives are pre-defined functions in the Scheme language. These include <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>set!</code>, <code>car</code>, <code>cdr</code>, and other basic procedures. Procedures are user-defined functions. In several variations of Scheme, a user can <!--del_lnk--> redefine a primitive. For example, the code<pre>
(define (+ x y)
  (- x y))
</pre><p>or simply<pre>
(define + -)
</pre><p>actually redefines the + primitive to perform subtraction, rather than addition.<p><a id="Lists" name="Lists"></a><h3> <span class="mw-headline">Lists</span></h3>
      <p>Scheme uses the <!--del_lnk--> linked list data structure in the same form as it exists in <!--del_lnk--> Lisp. &quot;list&quot; builds a new linked list structure, for example:<dl>
       <dd><code>(list 1 2 3) (list (list 1 2) 3)</code></dl>
      <p>&quot;<!--del_lnk--> car&quot; (pronounced: [k&#xFFFD;`r] <span class="unicode audiolink"><!--del_lnk--> listen</span> ) gives the value of the head node of the list, for example:<dl>
       <dd><code>(car (list 1 2 3))</code></dl>
      <p>gives<dl>
       <dd><code>1</code></dl>
      <p>and<dl>
       <dd><code>(car (list (list 1 2) 3))</code></dl>
      <p>gives<dl>
       <dd><code>(1 2)</code></dl>
      <p>&quot;<!--del_lnk--> cdr&quot; (pronounced &quot;could-er&quot; [&#39;k&#x259;d&#x259;r <span class="unicode audiolink"><!--del_lnk--> listen</span> ] or [&#39;kud&#x259;r]) gives the list after the head node, for example:<dl>
       <dd><code>(cdr (list 1 2 3))</code></dl>
      <p>gives<dl>
       <dd><code>(2 3)</code></dl>
      <p>and<dl>
       <dd><code>(cdr (list (list 1 2) 3)</code></dl>
      <p>gives<dl>
       <dd><code>(3)</code></dl>
      <p>&quot;<!--del_lnk--> cons&quot; constructs a new list with a given car value and cdr list, for example:<dl>
       <dd><code>(cons 1 (list 2 3))</code></dl>
      <p>gives<dl>
       <dd><code>(1 2 3)</code></dl>
      <p>and<dl>
       <dd><code>(cons (list 1 2) (list 3))</code></dl>
      <p>gives<dl>
       <dd><code>((1 2) 3)</code></dl>
      <div class="floatright"><span><a class="image" href="../../images/77/7779.png.htm" title="A box and pointer diagram"><img alt="A box and pointer diagram" height="72" longdesc="/wiki/Image:Schemeboxandptr.PNG" src="../../images/77/7779.png" width="189" /></a></span></div>
      <p>
       <br /> Each node in the linked list is a cons cell, also called a pair. As the name pair implies, a cons cell consists of two values: the first one is the car, and the second is the cdr. For<dl>
       <dd><code>(list 1 2 3)</code></dl>
      <p>there are three cons cells, or pairs. The first cons cell has the number 1 in the first slot, and a pointer to the second cons cell in the second. The second cons cell has the number 2 in the first slot, and a pointer to the third cons cell in the second slot. The third cons cell has the number 3 in the first slot and a null constant in the second slot. The null constant is usually represented by <code>&#39;()</code> or <code>(quote ())</code>. The cons function constructs these cons cells, which is why<dl>
       <dd><code>(cons 1 (list 2 3))</code></dl>
      <p>gives the list<dl>
       <dd><code>(1 2 3)</code></dl>
      <p>If both of the arguments are not lists, then a pair is created, represented with a dot. For example<dl>
       <dd><code>(cons 1 2)</code></dl>
      <p>gives<dl>
       <dd><code>(1 . 2)</code></dl>
      <p>where the cons cell consists of 1 and 2 in its slots instead of a pointer to another cons cell in its second slot.<p>The names of the two primitive operations for decomposing lists, <!--del_lnk--> car and cdr, originally come from assembly language macros for the <!--del_lnk--> IBM 704; they stood for &quot;contents of address register&quot; and &quot;contents of decrement register&quot; respectively.<p><a id="Data_types" name="Data_types"></a><h3> <span class="mw-headline">Data types</span></h3>
      <p>Other common data types in Scheme besides functions and lists are: <!--del_lnk--> integer, <!--del_lnk--> rational, <!--del_lnk--> real, <!--del_lnk--> complex numbers, <!--del_lnk--> symbols, <!--del_lnk--> strings, and ports. Most Scheme implementations also offer <!--del_lnk--> association lists, <!--del_lnk--> hash tables, <!--del_lnk--> vectors, <!--del_lnk--> arrays and <!--del_lnk--> structures. Since the IEEE Scheme standard and the R4RS Scheme standard, Scheme has asserted that all of the above types are <i>disjoint</i>, that is no value can belong to more than one of these types; however some ancient implementations of Scheme predate these standards such that <code>#f</code> and <code>&#39;()</code> refer to the same value, as is the case in Common Lisp.<p>Most Scheme implementations offer a full <!--del_lnk--> numerical tower as well as exact and inexact arithmetic.<p>True and false are represented by <code>#t</code> and <code>#f</code>. Actually only <code>#f</code> is really false when a Boolean type is required, everything else will be considered true, including the empty list. Symbols can be created in at least the following ways:<pre>
 &#39;symbol
 (string-&gt;symbol &quot;symbol&quot;)
</pre><p><a id="Equality" name="Equality"></a><h3> <span class="mw-headline">Equality</span></h3>
      <p>Scheme has three different types of equality: &quot;<code>eq?</code>&quot; returns <code>#t</code> if its parameters represent the same data object in memory; &quot;<code>eqv?</code>&quot; is generally the same as <code>eq?</code> but treats some objects (eg. characters and numbers) specially so that numbers that are <code>=</code> are <code>eqv?</code> even if they are not <code>eq?</code>; <code>equal?</code> compares data structures such as lists, vectors and strings to determine if they have congruent structure and <code>eqv?</code> contents.<p>Type dependent equivalence operations also exist in Scheme: <code>string=?</code>; compares two strings; <code>char=?</code> compares characters; <code>=</code> compares numbers.<p><a id="Control_structures" name="Control_structures"></a><h3> <span class="mw-headline">Control structures</span></h3>
      <p><a id="Conditional_evaluation" name="Conditional_evaluation"></a><h4> <span class="mw-headline">Conditional evaluation</span></h4><pre>
 (if test then-expr else-expr)
</pre><p>The <code>test</code> expression is evaluated, and if the evaluation result is true (anything other than <code>#f</code>) then the <code>then-expr</code> is evaluated, otherwise <code>else-expr</code> is evaluated.<p>A form that is more convenient when conditionals are nested is <code>cond</code>:<pre>
 (cond (test1 expr1 ...)
       (test2 expr2 ...)
       ...
       (else exprn))
</pre><p>The first expression for which the test evaluates to true will be evaluated. If all tests result in <code>#f</code>, the <code>else</code> clause is evaluated.<p>A variant of the cond clause is<pre>
 (cond ...
       (test =&gt; expr)
       ...)
</pre><p>In this case, <code>expr</code> should evaluate to a function that takes one argument. If test evaluates to true, the function is called with the return value of test.<p><a id="Loops" name="Loops"></a><h4> <span class="mw-headline">Loops</span></h4>
      <p>Loops in Scheme usually take the form of <!--del_lnk--> tail recursion. Scheme implementations are required to optimize tail calls so as to eliminate use of stack space where possible, so arbitrarily long loops can be executed using this technique.<p>A classic example is the factorial function, which can be defined non-tail-recursively:<pre>
 (define (factorial n)
   (if (= n 0)
     1
     (* n (factorial (- n 1)))))
</pre> <pre>
 (factorial 5)
 ;; =&gt; 120
</pre><p>This is a direct translation of the mathematical recursive definition of the factorial: the factorial of zero (usually written <i>0!</i>) is equal to 1, while the factorial of any greater natural number <i>n</i> is defined as <span class="texhtml"><i>n</i>! = <i>n</i> * (<i>n</i> &minus; 1)!</span>.<p>However, plain recursion is by nature less efficient, since the Scheme system must maintain a stack to keep track of the returns of all the nested function calls. A tail-recursive definition is one that ensures that in the recursive case, the outermost call is one back to the top of the recurring function. In this case, we recur not on the <code>factorial</code> function itself, but on a helper routine with two parameters representing the state of the iteration:<pre>
 (define (factorial n)
   (let loop ((total 1)
              (i n))
     (if (= i 0)
       total
       (loop (* i total) (- i 1)))))
</pre> <pre>
 (factorial 5)
 ;; =&gt; 120
</pre><p>A higher order function like <i>map</i>, which applies a function to every element of a list, can be defined non-tail-recursively:<pre>
 (define (map f lst)
   (if (null? lst)
     lst
     (cons (f (car lst))
           (map f (cdr lst)))))
</pre> <pre>
 (map (lambda (x) (* x x)) &#39;(1 2 3 4))
 ;;  =&gt; (1 4 9 16)
</pre><p>or can also be defined tail-recursively:<pre>
 (define (map f lst)
   (let loop ((lst lst)
              (res &#39;()))
     (if (null? lst)
       (reverse res)
       (loop (cdr lst)
             (cons (f (car lst)) res)))))
</pre> <pre>
 (map (lambda (x) (* x x)) &#39;(1 2 3 4))
 ;; =&gt; (1 4 9 16)
</pre><p>In both cases the tail-recursive version is preferable due to its decreased use of space.<p>For basic looping, Scheme supports a simple <i>do</i> iterator construct:<pre>
 (do ((&lt;variable1&gt; &lt;init1&gt; &lt;step1&gt;)
    ...)
  (&lt;test&gt; &lt;expression&gt; ...)
  &lt;command&gt; ...)
</pre><p>For example:<pre>
 (let ((x &#39;(1 3 5 7 9)))
   (do ((x x (cdr x))
        (sum 0 (+ sum (car x))))
      ((null? x) sum)))
</pre><p><a id="Input.2Foutput" name="Input.2Foutput"></a><h3> <span class="mw-headline">Input/output</span></h3>
      <p>Scheme has the concept of <i>ports</i> to read from or to write to. R5RS defines two default ports, accessible with the functions <code>current-input-port</code> and <code>current-output-port</code>, which correspond to the Unix notions of stdin and stdout. Most implementations also provide <code>current-error-port</code>.<p><a id="Examples" name="Examples"></a><h2> <span class="mw-headline">Examples</span></h2>
      <p><a id="Hello_world" name="Hello_world"></a><h3> <span class="mw-headline">Hello world</span></h3><pre>
 (begin
   (display &quot;Hello, World!&quot;)
   (newline))
</pre><p><a id="OOP_by_alist_.28association_list.29" name="OOP_by_alist_.28association_list.29"></a><h3> <span class="mw-headline">OOP by alist (association list)</span></h3><pre>
 ;; OOP(object-oriented programming) by alist(association list) example
 (define (cat-construct age color size) ;; constructor
   (list (cons &#39;age age)
         (cons &#39;color colour)
         (cons &#39;size size)))
</pre> <pre>
 ;; cat meows (its age) times
 (define (cat-meow cat)
   (let loop ((iteration (cdr (assoc &#39;age cat))))
     (if (&gt; iteration 0)
         (begin
           (display &quot;Meow!\n&quot;)
           (loop (- iteration 1))))))
</pre> <pre>
 (define billy (cat-construct 3 &#39;white &#39;small))
 (display &quot;billy&#39;s age: &quot;)
 (display (cdr (assoc &#39;age billy))) (newline)
 (display &quot;billy&#39;s color: &quot;)
 (display (cdr (assoc &#39;colour billy))) (newline)
 (cat-meow billy)
</pre><p>Scheme code can be found in the following articles:<ul>
       <li><!--del_lnk--> Arithmetic-geometric mean<li><!--del_lnk--> Church numeral<li><!--del_lnk--> Continuation passing style<li><!--del_lnk--> Call-with-current-continuation (aka &quot;call/cc&quot;)<li><!--del_lnk--> Currying<li><!--del_lnk--> Fibonacci number program<li><!--del_lnk--> wikibooks:Transwiki:List of hello world programs<li><!--del_lnk--> Infinite loop<li><!--del_lnk--> Tail recursion<li><!--del_lnk--> Queue<li><!--del_lnk--> Quine (computing)</ul>
      <p><a id="See_also" name="See_also"></a><div class="printfooter"> Retrieved from &quot;<!--del_lnk--> http://en.wikipedia.org/wiki/Scheme_%28programming_language%29&quot;</div>
      <!-- end content -->
      <div class="visualClear">
      </div>
     </div>
    </div>
   </div>
   <!-- end of the left (by default at least) column -->
   <div class="visualClear">
   </div>
   <div id="footer">
    <div class="center"> This reference article is mainly selected from the English Wikipedia with only minor checks and changes (see www.wikipedia.org for details of authors and sources) and is available under the <nobr><a href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm">GNU Free Documentation License</a></nobr>. See also our <b><a href="../../disclaimer.htm">Disclaimer</a></b>. </div>
   </div>
   <script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
  </div>
  
 </body>
</html>
