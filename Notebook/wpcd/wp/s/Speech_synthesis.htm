<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html dir="ltr" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <meta content="Speech synthesis,MS Sam.ogg,1939 New York World&#39;s Fair,2001: A Space Odyssey,2006,Abbreviation,Albertus Magnus,Alvin Liberman,Amiga,AmigaOS,Apple Computer" name="keywords" />
  <link href="../../favicon.ico" rel="shortcut icon" />
  <link href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm" rel="copyright" />
  <title>Speech synthesis</title>
  <style media="screen,projection" type="text/css">/*<![CDATA[*/ @import "../../css/wp-monobook-main.css"; /*]]>*/</style>
  <link href="../../css/wp-commonPrint.css" media="print" rel="stylesheet" type="text/css" />
  <!--[if lt IE 5.5000]><style type="text/css">@import "../../css/IE50Fixes.css";</style><![endif]-->
  <!--[if IE 5.5000]><style type="text/css">@import "../../css/IE55Fixes.css";</style><![endif]-->
  <!--[if IE 6]><style type="text/css">@import "../../css/IE60Fixes.css";</style><![endif]-->
  <!--[if IE 7]><style type="text/css">@import "../../css/IE70Fixes.css";</style><![endif]-->
  <!--[if lt IE 7]><script type="text/javascript" src="../../js/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
  <script type="text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";

			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "Speech_synthesis";
			var wgTitle = "Speech synthesis";
			var wgArticleId = 42799;
			var wgCurRevisionId = 92227938;
			var wgIsArticle = true;
		
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
  <script src="../../js/wikibits.js" type="text/javascript"><!-- wikibits js --></script>
  <script src="../../js/wp.js" type="text/javascript"><!-- site js --></script>
  <style type="text/css">/*<![CDATA[*/
@import "../../css/wp-common.css";
@import "../../css/wp-monobook.css";
@import "../../css/wp.css";
/*]]>*/</style>
  <!-- Head Scripts -->
 </head>
 <body class="mediawiki ns-0 ltr page-Speech_synthesis">
  <div id="globalWrapper">
   <div id="column-content">
    <div id="content"><a id="top" name="top"></a><h1 class="firstHeading">Speech synthesis</h1>
     <div id="bodyContent">
      <h3 id="siteSub"><a href="../../index.htm">2007 Schools Wikipedia Selection</a>. Related subjects: <a href="../index/subject.IT.Software.htm">Software</a></h3>
      <!-- start content -->
      <p><b>Speech synthesis</b> is the artificial production of human <!--del_lnk--> speech. A computer system used for this purpose is called a <b>speech synthesizer</b>, and can be implemented in <!--del_lnk--> software or <!--del_lnk--> hardware. A <b>text-to-speech (TTS)</b> system converts normal language text into speech; other systems render <!--del_lnk--> symbolic linguistic representations like <!--del_lnk--> phonetic transcriptions into speech.<p>Synthesized speech can be created by concatenating pieces of recorded speech that are stored in a <!--del_lnk--> database. Systems differ in the size of the stored speech units; a system that stores <!--del_lnk--> phones or <!--del_lnk--> diphones provides the largest output range, but may lack clarity. For specific usage domains, the storage of entire words or sentences allows for high-quality output. Alternatively, a synthesizer can incorporate a model of the <!--del_lnk--> vocal tract and other human voice characteristics to create a completely &quot;synthetic&quot; voice output.<p>The quality of a speech synthesizer is judged by its similarity to the human voice, and by its ability to be understood. An intelligible text-to-speech program allows people with <!--del_lnk--> visual impairments or <!--del_lnk--> reading disabilities to listen to written works on a home computer. Many computer operating systems have included speech synthesizers since the early 1980s.<p>
       <script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script><a id="Overview_of_text_processing" name="Overview_of_text_processing"></a><h2> <span class="mw-headline">Overview of text processing</span></h2>
      <p>A text-to-speech system (or &quot;engine&quot;) is composed of two parts: a <!--del_lnk--> front-end and a back-end. The front-end has two major tasks. First, it converts raw text containing symbols like numbers and abbreviations into the equivalent of written-out words. This process is often called <i>text normalization</i>, <i>pre-processing</i>, or <i><!--del_lnk--> tokenization</i>. The front-end then assigns <!--del_lnk--> phonetic transcriptions to each word, and divides and marks the text into <!--del_lnk--> prosodic units, like <!--del_lnk--> phrases, <!--del_lnk--> clauses, and <!--del_lnk--> sentences. The process of assigning phonetic transcriptions to words is called <i>text-to-phoneme</i> or <i><!--del_lnk--> grapheme-to-phoneme</i> conversion. Phonetic transcriptions and prosody information together make up the symbolic linguistic representation that is output by the front-end. The back-end&mdash;often referred to as the <i>synthesizer</i>&mdash;then converts the symbolic linguistic representation into sound.<p><a id="History" name="History"></a><h2> <span class="mw-headline">History</span></h2>
      <p><a id="Mechanical_devices" name="Mechanical_devices"></a><h3> <span class="mw-headline">Mechanical devices</span></h3>
      <p>Long before <a href="../../wp/e/Electronics.htm" title="Electronics">electronic</a> <!--del_lnk--> signal processing was invented, speech researchers tried to build machines to create human speech. Early examples of &quot;speaking heads&quot; were made by <!--del_lnk--> Gerbert of Aurillac (d. 1003 AD), <!--del_lnk--> Albertus Magnus (1198&ndash;1280), and <!--del_lnk--> Roger Bacon (1214&ndash;1294).<p>In 1779, the <a href="../../wp/d/Denmark.htm" title="Denmark">Danish</a> scientist Christian Kratzenstein, working at the <!--del_lnk--> Russian Academy of Sciences, built models of the human <!--del_lnk--> vocal tract that could produce the five long <a href="../../wp/v/Vowel.htm" title="Vowel">vowel</a> sounds (in <!--del_lnk--> International Phonetic Alphabet notation, they are <span class="IPA" title="Pronunciation in IPA">[a&#x2D0;]</span>, <span class="IPA" title="Pronunciation in IPA">[e&#x2D0;]</span>, <span class="IPA" title="Pronunciation in IPA">[i&#x2D0;]</span>, <span class="IPA" title="Pronunciation in IPA">[o&#x2D0;]</span> and <span class="IPA" title="Pronunciation in IPA">[u&#x2D0;]</span>). This was followed by the <!--del_lnk--> bellows-operated &quot;acoustic-mechanical speech machine&quot; by <!--del_lnk--> Wolfgang von Kempelen of <a href="../../wp/v/Vienna.htm" title="Vienna">Vienna</a>, <a href="../../wp/a/Austria.htm" title="Austria">Austria</a>, described in a 1791 paper. This machine added models of the tongue and lips, enabling it to produce <!--del_lnk--> consonants as well as vowels. In 1837, <!--del_lnk--> Charles Wheatstone produced a &quot;speaking machine&quot; based on von Kempelen&#39;s design, and in 1857, M. Faber built the &quot;Euphonia&quot;. Wheatstone&#39;s design was resurrected in 1923 by Paget.<p>In the 1930s, <!--del_lnk--> Bell Labs developed the <!--del_lnk--> VOCODER, a keyboard-operated electronic speech analyzer and synthesizer that was said to be clearly intelligible. Homer Dudley refined this device into the VODER, which he exhibited at the <!--del_lnk--> 1939 New York World&#39;s Fair.<p>The <!--del_lnk--> Pattern playback was built by Dr. Franklin S. Cooper and his colleagues at <!--del_lnk--> Haskins Laboratories in the late 1940s and completed in 1950. There were several different versions of this hardware device but only one currently survives. The machine converts pictures of the acoustic patterns of speech in the form of a spectrogram back into sound. Using this device, <!--del_lnk--> Alvin Liberman and colleagues were able to discover acoustic cues for the perception of <!--del_lnk--> phonetic segments (consonants and vowels).<p>Early electronic speech synthesizers sounded robotic and were often barely intelligible. However, the quality of synthesized speech has steadily improved, and output from contemporary speech synthesis systems is sometimes indistinguishable from actual human speech.<p><a id="Electronic_devices" name="Electronic_devices"></a><h3> <span class="mw-headline">Electronic devices</span></h3>
      <p>The first computer-based speech synthesis systems were created in the late 1950s, and the first complete text-to-speech system was completed in 1968. In 1961, physicist <!--del_lnk--> John Larry Kelly, Jr used an <!--del_lnk--> IBM 704 computer to synthesize speech, an event among the most prominent in the history of <!--del_lnk--> Bell Labs. Kelly&#39;s voice recorder synthesizer (vocoder) recreated the song &quot;<!--del_lnk--> Daisy Bell&quot;, with musical accompaniment from <!--del_lnk--> Max Mathews. Coincidentally, <!--del_lnk--> Arthur C. Clarke was visiting his friend and colleague John Pierce at the Bell Labs Murray Hill facility. Clarke was so impressed by the demonstration that he used it in the climactic scene of his screenplay for his novel <i><!--del_lnk--> 2001: A Space Odyssey</i>, where the <!--del_lnk--> HAL 9000 computer sings the same song as it is being put to sleep by astronaut <!--del_lnk--> Dave Bowman.<p>Despite the success of purely electronic speech synthesis, research is still being conducted into mechanical speech synthesizers for use in humanoid <!--del_lnk--> robots. Even a perfect electronic synthesizer is limited by the quality of the <!--del_lnk--> transducer (usually a <!--del_lnk--> loudspeaker) that produces the sound, so, in a robot, a mechanical system may be able to produce a more natural sound than a small loudspeaker.<p><a id="Synthesizer_technologies" name="Synthesizer_technologies"></a><h2> <span class="mw-headline">Synthesizer technologies</span></h2>
      <p>The most important qualities of a speech synthesis system are <i>naturalness</i> and <i>intelligibility</i>. Naturalness describes how closely the output sounds like human speech, while intelligibility is the ease with which the output is understood. The ideal speech synthesizer is both natural and intelligible and most speech synthesis systems try to maximize both characteristics.<p>The two primary technologies for generating synthetic speech waveforms are <i>concatenative synthesis</i> and <i><!--del_lnk--> formant synthesis</i>. Each technology has strengths and weaknesses, and the intended uses of a synthesis system will typically determine which approach is used.<p><a id="Concatenative_synthesis" name="Concatenative_synthesis"></a><h3> <span class="mw-headline">Concatenative synthesis</span></h3>
      <p>Concatenative synthesis is based on the <!--del_lnk--> concatenation (or stringing together) of segments of recorded speech. Generally, concatenative synthesis produces the most natural-sounding synthesized speech. However, differences between natural variations in speech and the nature of the automated techniques for segmenting the waveforms sometimes result in audible glitches in the output. There are three main subtypes of concatenative synthesis.<p><a id="Unit_selection_synthesis" name="Unit_selection_synthesis"></a><h4> <span class="mw-headline">Unit selection synthesis</span></h4>
      <p>Unit selection synthesis uses large <!--del_lnk--> databases of recorded speech. During database creation, each recorded utterance is segmented into some or all of the following: individual <!--del_lnk--> phones, <!--del_lnk--> syllables, <!--del_lnk--> morphemes, <!--del_lnk--> words, <!--del_lnk--> phrases, and <!--del_lnk--> sentences. Typically, the division into segments is done using a specially modified <!--del_lnk--> speech recognizer set to a &quot;forced alignment&quot; mode with some manual correction afterward, using visual representations such as the <!--del_lnk--> waveform and <!--del_lnk--> spectrogram. An <!--del_lnk--> index of the units in the speech database is then created based on the segmentation and acoustic parameters like the <!--del_lnk--> fundamental frequency (<!--del_lnk--> pitch), duration, position in the syllable, and neighboring phones. At <!--del_lnk--> runtime, the desired target utterance is created by determining the best chain of candidate units from the database (unit selection). This process is typically achieved using a specially weighted <!--del_lnk--> decision tree.<p>Unit selection provides the greatest naturalness, because it applies only a small amount of <!--del_lnk--> digital signal processing (DSP) to the recorded speech. DSP often makes recorded speech sound less natural, although some systems use a small amount of signal processing at the point of concatenation to smooth the waveform. The output from the best unit-selection systems is often indistinguishable from real human voices, especially in contexts for which the TTS system has been tuned. However, maximum naturalness typically require unit-selection speech databases to be very large, in some systems ranging into the <!--del_lnk--> gigabytes of recorded data, representing dozens of hours of speech.<p><a id="Diphone_synthesis" name="Diphone_synthesis"></a><h4> <span class="mw-headline">Diphone synthesis</span></h4>
      <p>Diphone synthesis uses a minimal speech database containing all the <!--del_lnk--> diphones (sound-to-sound transitions) occurring in a language. The number of diphones depends on the <!--del_lnk--> phonotactics of the language: for example, Spanish has about 800 diphones, and German about 2500. In diphone synthesis, only one example of each diphone is contained in the speech database. At runtime, the target <!--del_lnk--> prosody of a sentence is superimposed on these minimal units by means of <!--del_lnk--> digital signal processing techniques such as <!--del_lnk--> linear predictive coding or <!--del_lnk--> PSOLA (used by <!--del_lnk--> MBROLA).<p>The quality of the resulting speech is generally worse than that of unit-selection systems, but more natural-sounding than the output of formant synthesizers. Diphone synthesis suffers from the sonic glitches of concatenative synthesis and the robotic-sounding nature of formant synthesis, and has few of the advantages of either approach other than small size. As such, its use in commercial applications is declining, although it continues to be used in research because there are a number of freely available software implementations.<p><a id="Domain-specific_synthesis" name="Domain-specific_synthesis"></a><h4> <span class="mw-headline">Domain-specific synthesis</span></h4>
      <p>Domain-specific synthesis concatenates prerecorded words and phrases to create complete utterances. It is used in applications where the variety of texts the system will output is limited to a particular domain, like transit schedule announcements or weather reports. The technology is very simple to implement, and has been in commercial use for a long time, in devices like talking clocks and calculators. The level of naturalness of these systems can be very high because the variety of sentence types is limited, and they closely match the prosody and intonation of the original recordings. Because these systems are limited by the words and phrases in their databases, they are not general-purpose and can only synthesize the combinations of words and phrases with which they have been preprogrammed.<p><a id="Formant_synthesis" name="Formant_synthesis"></a><h3> <span class="mw-headline">Formant synthesis</span></h3>
      <p><!--del_lnk--> Formant synthesis does not use human speech samples at runtime. Instead, the synthesized speech output is created using an acoustic model. Parameters such as <!--del_lnk--> fundamental frequency, <!--del_lnk--> voicing, and <!--del_lnk--> noise levels are varied over time to create a <!--del_lnk--> waveform of artificial speech. This method is sometimes called <i>rules-based synthesis</i>; however, many concatenative systems also have rules-based components.<p>Many systems based on formant synthesis technology generate artificial, robotic-sounding speech that would never be mistaken for human speech. However, maximum naturalness is not always the goal of a speech synthesis system, and formant synthesis systems have advantages over concatenative systems. Formant-synthesized speech can be reliably intelligible, even at very high speeds, avoiding the acoustic glitches that commmonly plague concatenative systems. High-speed synthesized speech is used by the visually impaired to quickly navigate computers using a <!--del_lnk--> screen reader. Formant synthesizers are usually smaller programs than concatenative systems because they do not have a database of speech samples. They can therefore be used in <!--del_lnk--> embedded systems, where <!--del_lnk--> memory and <!--del_lnk--> microprocessor power are especially limited. Because formant-based systems have complete control of all aspects of the output speech, a wide variety of prosodies and <!--del_lnk--> intonations can be output, conveying not just questions and statements, but a variety of emotions and tones of voice.<p>Examples of non-real-time but highly accurate intonation control in formant synthesis include the work done in the late 1970s for the <!--del_lnk--> Texas Instruments toy <!--del_lnk--> Speak &amp; Spell, and in the early 1980s <!--del_lnk--> Sega <!--del_lnk--> arcade machines. Creating proper intonation for these projects was painstaking, and the results have yet to be matched by real-time text-to-speech interfaces.<p><a id="Articulatory_synthesis" name="Articulatory_synthesis"></a><h3> <span class="mw-headline">Articulatory synthesis</span></h3>
      <p>Articulatory synthesis refers to computational techniques for synthesizing speech based on models of the human <!--del_lnk--> vocal tract and the articulation processes occurring there. The first articulatory synthesizer regularly used for laboratory experiments was developed at <!--del_lnk--> Haskins Laboratories in the mid-1970s by <!--del_lnk--> Philip Rubin, Tom Baer, and Paul Mermelstein. This synthesizer, known as ASY, was based on vocal tract models developed at Bell Laboratories in the 1960s and 1970s by Paul Mermelstein, Cecil Coker, and colleagues.<p>Articulatory synthesis has been mostly of academic interest until recently. Few of these models are currently sufficiently advanced or computationally efficient to be used in commercial speech synthesis systems. A notable exception is the <!--del_lnk--> NeXT-based system originally developed and marketed by Trillium Sound Research, a spin-off company of the <!--del_lnk--> University of Calgary, where much of the original research was conducted. Following the demise of the various incarnations of NeXT (started by <!--del_lnk--> Steve Jobs in the late 1980s and merged with Apple Computer in 1997), the Trillium software was published under a <!--del_lnk--> GNU General Public Licence, with work continuing as <i>gnuspeech</i>. The system, first marketed in 1994, provides full articulatory-based text-to-speech conversion using a waveguide or transmission-line analog of the human oral and nasal tracts controlled by Carr&eacute;&#39;s &quot;distinctive region model&quot;.<p><a id="HMM-based_synthesis" name="HMM-based_synthesis"></a><h3> <span class="mw-headline">HMM-based synthesis</span></h3>
      <p>HMM-based synthesis is a synthesis method based on <!--del_lnk--> hidden Markov models. In this system, the <!--del_lnk--> frequency spectrum (<!--del_lnk--> vocal tract), <!--del_lnk--> fundamental frequency (vocal source), and duration (<!--del_lnk--> prosody) of speech are modeled simultaneously by HMMs. Speech <!--del_lnk--> waveforms are generated from HMMs themselves based on <!--del_lnk--> maximum likelihood criteria.<p><a id="Sinewave_synthesis" name="Sinewave_synthesis"></a><h3> <span class="mw-headline">Sinewave synthesis</span></h3>
      <p><!--del_lnk--> Sinewave synthesis is a technique for synthesizing speech by replacing the <!--del_lnk--> formants (main bands of energy) with pure tone whistles.<p><a id="Challenges" name="Challenges"></a><h2> <span class="mw-headline">Challenges</span></h2>
      <p><a id="Text_normalization_challenges" name="Text_normalization_challenges"></a><h3> <span class="mw-headline">Text normalization challenges</span></h3>
      <p>The process of normalizing text is rarely straightforward. Texts are full of <!--del_lnk--> heteronyms, <a href="../../wp/n/Number.htm" title="Number">numbers</a>, and <!--del_lnk--> abbreviations that all require expansion into a phonetic representation. There are many spellings in English which are pronounced differently based on context. For example, &quot;My latest project is to learn how to better project my voice&quot; contains two pronunciations of &quot;project&quot;.<p>Most text-to-speech (TTS) systems do not generate semantic representations of their input texts, as processes for doing so are not reliable, well understood, or computationally effective. As a result, various <!--del_lnk--> heuristic techniques are used to guess the proper way to disambiguate homographs, like examining neighboring words and using statistics about frequency of occurrence.<p>Deciding how to convert numbers is another problem that TTS systems have to address. It is a simple programming challenge to convert a number into words, like &quot;1325&quot; becoming &quot;one thousand three hundred twenty-five.&quot; However, numbers occur in many different contexts; when part of an address, &quot;1325&quot; should likely be read as &quot;thirteen twenty-five&quot;, or, when part of a social security number, as &quot;one three two five&quot;. A TTS system can often infer how to expand a number based on surrounding words, numbers, and punctuation, and sometimes the system provides a way to specify the context if it is ambiguous.<p>Similarly, abbreviations can be ambiguous. For example, the abbreviation &quot;in&quot; for &quot;inches&quot; must be differentiated from the word &quot;in&quot;. TTS systems with intelligent front ends can make educated guesses about ambiguous abbreviations, while others provide the same result in all cases, resulting in nonsensical (and sometimes comical) outputs.<p><a id="Text-to-phoneme_challenges" name="Text-to-phoneme_challenges"></a><h3> <span class="mw-headline">Text-to-phoneme challenges</span></h3>
      <p>Speech synthesis systems use two basic approaches to determine the pronunciation of a word based on its spelling, a process which is often called text-to-phoneme or grapheme-to-phoneme conversion (<!--del_lnk--> phoneme is the term used by <!--del_lnk--> linguists to describe distinctive sounds in a language). The simplest approach to text-to-phoneme conversion is the dictionary-based approach, where a large dictionary containing all the words of a language and their correct pronunciations is stored by the program. Determining the correct pronunciation of each word is a matter of looking up each word in the dictionary and replacing the spelling with the pronunciation specified in the dictionary. The other approach is rule-based, in which pronunciation rules are applied to words to determine their pronunciations based on their spellings. This is similar to the &quot;sounding out&quot;, or <!--del_lnk--> synthetic phonics, approach to learning reading.<p>Each approach has advantages and drawbacks. The dictionary-based approach is quick and accurate, but completely fails if it is given a word which is not in its dictionary. As dictionary size grows, so too does the memory space requirements of the synthesis system. On the other hand, the rule-based approach works on any input, but the complexity of the rules grows substantially as the system takes into account irregular spellings or pronunciations. (Consider that the word &quot;of&quot; is very common in English, yet is the only word in which the letter &quot;f&quot; is pronounced [v].) As a result, nearly all speech synthesis systems use a combination of these approaches.<p>Some languages, like <a href="../../wp/s/Spanish_language.htm" title="Spanish language">Spanish</a>, have a very regular writing system, and the prediction of the pronunciation of words based on their spellings is quite successful. Speech synthesis systems for such languages often use the rule-based method extensively, resorting to dictionaries only for those few words, like foreign names and borrowings, whose pronunciations are not obvious from their spellings. On the other hand, speech synthesis systems for languages like <a href="../../wp/e/English_language.htm" title="English language">English</a>, which have extremely irregular spelling systems, are more likely to rely on dictionaries, and to use rule-based methods only for unusual words, or words that aren&#39;t in their dictionaries.<p><a id="Computer_operating_systems_or_outlets_with_speech_synthesis" name="Computer_operating_systems_or_outlets_with_speech_synthesis"></a><h2> <span class="mw-headline">Computer operating systems or outlets with speech synthesis</span></h2>
      <p><a id="Apple" name="Apple"></a><h3> <span class="mw-headline">Apple</span></h3>
      <p>The first speech system integrated into an <!--del_lnk--> operating system was <!--del_lnk--> Apple Computer&#39;s <!--del_lnk--> MacInTalk in 1984. During most of the early 1990s, Apple voices were synthetic. More recently, Apple has added sample-based voices. Starting as a curiosity, the speech system of Apple <!--del_lnk--> Macintosh eventually evolved to a fully-supported program, <!--del_lnk--> PlainTalk, for people with vision problems.<p><a id="AmigaOS" name="AmigaOS"></a><h3> <span class="mw-headline">AmigaOS</span></h3>
      <p>The second operating system with advanced speech synthesis capabilities was <!--del_lnk--> AmigaOS, introduced in 1985. The voice synthesis was licensed by <!--del_lnk--> Commodore International from a third-party software house (Don&#39;t Ask Software, now Softvoice, Inc.) and it featured a complete system of voice emulation, with both male and female voices and &quot;stress&quot; indicator markers, made possible by advanced features of the <!--del_lnk--> Amiga hardware audio <!--del_lnk--> chipset. It was divided into a narrator device and a translator library. Amiga <!--del_lnk--> Speak Handler featured a text-to-speech translator. AmigaOS considered speech synthesis a virtual hardware device, so the user could even redirect console output to it. Some Amiga programs, such as word processors, made extensive use of the speech system.<p><a id="Microsoft_Windows" name="Microsoft_Windows"></a><h3> <span class="mw-headline">Microsoft Windows</span></h3>
      <p>Modern <a href="../../wp/m/Microsoft_Windows.htm" title="Microsoft Windows">Windows</a> systems use <!--del_lnk--> SAPI4- and <!--del_lnk--> SAPI5-based speech systems that include a <!--del_lnk--> speech recognition engine (SRE). SAPI 4.0 was available on Microsoft-based operating systems like <!--del_lnk--> Windows 95 and <!--del_lnk--> Windows 98. <a href="../../wp/w/Windows_XP.htm" title="Windows XP">Windows XP</a> featured a speech synthesis program called <!--del_lnk--> Narrator, directly available to users. All Windows-compatible programs could make use of speech synthesis features, available through menus once installed on the system. <!--del_lnk--> Microsoft Speech Server is a complete package for voice synthesis and recognition, for commercial applications such as <!--del_lnk--> call centers.<p><a id="Websites" name="Websites"></a><h3> <span class="mw-headline">Websites</span></h3>
      <p>Recently, websites such as Bluemountain.com have featured <!--del_lnk--> eCards that allow a user to produce custom-made vocal greetings from a computer-generated voice. These eCards usually consist of pre-made images, but some allow the user to select an image of whatever the user wants. All of the eCards allow the user to select the computer&#39;s vocabulary.<p><a id="Others" name="Others"></a><h3> <span class="mw-headline">Others</span></h3>
      <ul>
       <li>The 1979 and 1981 <!--del_lnk--> Texas Instruments TI-99/4 and TI-99/4A home computers were capable of text-to-phoneme synthesis or reciting complete words and phrases (text-to-dictionary), using a very popular Speech Synthesizer peripheral. TI used a proprietary <!--del_lnk--> codec to embed complete spoken phrases into applications, primarily video games.<li>Systems that operate on <a href="../../wp/l/Linux.htm" title="Linux">GNU/Linux</a> systems are various, and include <!--del_lnk--> open-source programs such as the <!--del_lnk--> Festival Speech Synthesis System which uses diphone-based synthesis (and can use a limited number of <!--del_lnk--> MBROLA voices), and gnuspeech which uses articulatory synthesis  from the <!--del_lnk--> Free Software Foundation. Other commercial vendor software also runs on GNU/Linux.<li>Several other commercial speech synthesis systems have been created, including one by the now-defunct <!--del_lnk--> Lernout &amp; Hauspie called TTS 3000. Acapela Group, AT&amp;T, Cepstral, <!--del_lnk--> DECtalk, <!--del_lnk--> IBM ViaVoice, NeoSpeech, and <!--del_lnk--> Nuance Communications all have commercial offerings as well.</ul>
      <p><a id="Speech_synthesis_markup_languages" name="Speech_synthesis_markup_languages"></a><h2> <span class="mw-headline">Speech synthesis markup languages</span></h2>
      <p>A number of <a href="../../wp/m/Markup_language.htm" title="Markup language">markup languages</a> have been established for the rendition of text as speech in an <!--del_lnk--> XML-compliant format. The most recent is <!--del_lnk--> Speech Synthesis Markup Language (SSML), which became a <!--del_lnk--> W3C recommendation in 2004. Older speech synthesis markup languages include Java Speech Markup Language (JSML) and SABLE. Although each of these was proposed as a standard, none of them has been widely adopted.<p>Speech synthesis markup languages are distinguished from dialogue markup languages. <!--del_lnk--> VoiceXML, for example, includes tags related to speech recognition, dialogue management and touchtone dialing, in addition to text-to-speech markup.<div class="printfooter"> Retrieved from &quot;<!--del_lnk--> http://en.wikipedia.org/wiki/Speech_synthesis&quot;</div>
      <!-- end content -->
      <div class="visualClear">
      </div>
     </div>
    </div>
   </div>
   <!-- end of the left (by default at least) column -->
   <div class="visualClear">
   </div>
   <div id="footer">
    <div class="center"> This reference article is mainly selected from the English Wikipedia with only minor checks and changes (see www.wikipedia.org for details of authors and sources) and is available under the <nobr><a href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm">GNU Free Documentation License</a></nobr>. See also our <b><a href="../../disclaimer.htm">Disclaimer</a></b>. </div>
   </div>
   <script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
  </div>
  
 </body>
</html>
