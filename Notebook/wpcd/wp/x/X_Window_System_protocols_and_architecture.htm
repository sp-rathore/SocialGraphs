<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html dir="ltr" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <meta content="X Window System protocols and architecture,Motif (widget toolkit),Tk (computing),XView,OPEN LOOK,Project Athena,AT&amp;T,Sun Microsystems,Unix,Desktop environment,Common Desktop Environment" name="keywords" />
  <link href="../../favicon.ico" rel="shortcut icon" />
  <link href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm" rel="copyright" />
  <title>X Window System protocols and architecture</title>
  <style media="screen,projection" type="text/css">/*<![CDATA[*/ @import "../../css/wp-monobook-main.css"; /*]]>*/</style>
  <link href="../../css/wp-commonPrint.css" media="print" rel="stylesheet" type="text/css" />
  <!--[if lt IE 5.5000]><style type="text/css">@import "../../css/IE50Fixes.css";</style><![endif]-->
  <!--[if IE 5.5000]><style type="text/css">@import "../../css/IE55Fixes.css";</style><![endif]-->
  <!--[if IE 6]><style type="text/css">@import "../../css/IE60Fixes.css";</style><![endif]-->
  <!--[if IE 7]><style type="text/css">@import "../../css/IE70Fixes.css";</style><![endif]-->
  <!--[if lt IE 7]><script type="text/javascript" src="../../js/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
  <script type="text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";
                        
			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "X_Window_System_protocols_and_architecture";
			var wgTitle = "X Window System protocols and architecture";
			var wgArticleId = 1433274;
			var wgIsArticle = true;
                        
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
  <script src="../../js/wikibits.js" type="text/javascript"><!-- wikibits js --></script>
  <script src="../../js/wp.js" type="text/javascript"><!-- site js --></script>
  <style type="text/css">/*<![CDATA[*/
@import "../../css/wp-common.css";
@import "../../css/wp-monobook.css";
@import "../../css/wp.css";
/*]]>*/</style>
  <!-- Head Scripts -->
 </head>
 <body class="mediawiki ns-0 ltr page-X_Window_System_protocols_and_architecture">
  <div id="globalWrapper">
   <div id="column-content">
    <div id="content"><a id="top" name="top"></a><h1 class="firstHeading">X Window System protocols and architecture</h1>
     <div id="bodyContent">
      <h3 id="siteSub"><a href="../../index.htm">2007 Schools Wikipedia Selection</a>. Related subjects: <a href="../index/subject.IT.Software.htm">Software</a></h3>
      <!-- start content -->
      <div class="thumb tright">
       <div style="width:102px;"><a class="internal" href="../../images/229/22946.png.htm" title="The X Window System logo"><img alt="The X Window System logo" height="100" longdesc="/wiki/Image:X11.svg" src="../../images/229/22946.png" width="100" /></a><div class="thumbcaption">
         <div class="magnify" style="float:right"><a class="internal" href="../../images/229/22946.png.htm" title="Enlarge"><img alt="Enlarge" height="11" src="../../images/0/1.png" width="15" /></a></div> The X Window System logo</div>
       </div>
      </div>
      <p>In <!--del_lnk--> computing, the <b><a href="../../wp/x/X_Window_System.htm" title="X Window System">X Window System</a></b> (commonly <b>X11</b> or <b>X</b>) is a <!--del_lnk--> network-transparent <!--del_lnk--> windowing system for <!--del_lnk--> bitmap displays. This article details the protocols and technical structure of X11.<p>
       <script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script><a id="The_X_client-server_model_and_network_transparency" name="The_X_client-server_model_and_network_transparency"></a><h2> <span class="mw-headline">The X client-server model and network transparency</span></h2>
      <p>X is based on a <!--del_lnk--> client-server model. An <i>X server</i> program runs on a computer with a graphical display and communicates with various <i>client programs</i>. The server accepts requests for graphical output (windows) and sends back user input (keyboard, mouse).<p>In X Window, the server runs on the user&#39;s computer, while the clients may run on a different machine. This is the reverse of the common configuration of client-server systems, where the <i>client</i> runs on the user&#39;s computer and the server runs on a remote computer. This reversal often confuses new X users. The X Window terminology takes the perspective of the program, rather than the end-user or the hardware: the remote programs connect to the X server display running on the local machine, and thus act as clients; the local X display accepts incoming traffic, and thus acts as a server.<div class="thumb tright">
       <div style="width:252px;"><a class="internal" href="../../images/229/22947.png.htm" title="In this example, the X server takes input from a keyboard and mouse and displays to a screen. A web browser and a terminal emulator run on the user&#39;s workstation, and a system updater runs on a remote server but is controlled from the user&#39;s machine. Note that the remote application runs just as it would locally."><img alt="In this example, the X server takes input from a keyboard and mouse and displays to a screen. A web browser and a terminal emulator run on the user&#39;s workstation, and a system updater runs on a remote server but is controlled from the user&#39;s machine. Note that the remote application runs just as it would locally." height="422" longdesc="/wiki/Image:X_client_server_example.png" src="../../images/229/22947.png" width="250" /></a><div class="thumbcaption">In this example, the X server takes input from a keyboard and mouse and displays to a screen. A <!--del_lnk--> web browser and a <!--del_lnk--> terminal emulator run on the user&#39;s workstation, and a system updater runs on a remote server but is controlled from the user&#39;s machine. Note that the remote application runs just as it would locally.</div>
       </div>
      </div>
      <p>The <!--del_lnk--> communication protocol between server and client runs <!--del_lnk--> network-transparently: the client and server may run on the same machine or on different ones, possibly with different <!--del_lnk--> architectures and <!--del_lnk--> operating systems. A client and server can communicate <!--del_lnk--> securely over the <a href="../../wp/i/Internet.htm" title="Internet">Internet</a> by <!--del_lnk--> tunneling the connection over an encrypted connection.<p><a id="Design_principles" name="Design_principles"></a><h2> <span class="mw-headline">Design principles</span></h2>
      <p><!--del_lnk--> Bob Scheifler and <!--del_lnk--> Jim Gettys set out the early principles of X as follows (as listed in Scheifler/Gettys 1996):<ul>
       <li><i>Do not add new functionality unless an implementor cannot complete a real application without it.</i><li><i>It is as important to decide what a system is not as to decide what it is. Do not serve all the world&#39;s needs; rather, make the system extensible so that additional needs can be met in an upwardly compatible fashion.</i><li><i>The only thing worse than generalizing from one example is generalizing from no examples at all.</i><li><i>If a problem is not completely understood, it is probably best to provide no solution at all.</i><li><i>If you can get 90 percent of the desired effect for 10 percent of the work, use the simpler solution.</i> (See also <!--del_lnk--> Worse is better.)<li><i>Isolate complexity as much as possible.</i><li><i>Provide mechanism rather than policy. In particular, place user interface policy in the clients&#39; hands.</i></ul>
      <p>The first principle was modified during the design of X11 to: <i>&quot;Do not add new functionality unless you know of some real application that will require it.&quot;</i> X has largely kept to these principles since. The reference implementation is developed with a view to extension and improvement of the implementation, whilst remaining almost entirely compatible with the original 1987 protocol.<p><a id="X_Window_core_protocol" name="X_Window_core_protocol"></a><h2> <span class="mw-headline">X Window core protocol</span></h2>
      <dl>
       <dd>
      </dl>
      <p>Communication between server and clients is done by exchanging packets over a network channel. The connection is established by the client, which sends the first packet. The server answers by sending back a packet stating the acceptance or refusal of the connection, or with a request for a further authentication. If the connection is accepted, the acceptance packet contains data for the client to use in the subsequent interaction with the server.<p>After connection is established, four types of packets are exchanged by the client and the server over the channel:<ol>
       <li><b>Request:</b> The client requests information from the server or requests it to perform an action.<li><b>Reply:</b> The server responds to a request. Not all requests generate replies.<li><b>Event:</b> The server sends an event to the client, e.g., keyboard or mouse input, or a window being moved, resized or exposed.<li><b>Error:</b> The server sends an error packet if a request is invalid. Since requests are queued, error packets generated by a request may not be sent immediately.</ol>
      <p>The X server provides a set of basic services. The client programs realize more complex functionalities by interacting with the server.<p><a id="Windows" name="Windows"></a><h3> <span class="mw-headline">Windows</span></h3>
      <div class="thumb tright">
       <div style="width:319px;"><a class="internal" href="../../images/229/22948.png.htm" title="A possible placement of some windows: 1 is the root window, which covers the whole screen; 2 and 3 are top-level windows; 4 and 5 are subwindows of 2. The parts of window that are outside its parent are not visible."><img alt="A possible placement of some windows: 1 is the root window, which covers the whole screen; 2 and 3 are top-level windows; 4 and 5 are subwindows of 2. The parts of window that are outside its parent are not visible." height="217" longdesc="/wiki/Image:Some_X_windows.png" src="../../images/229/22948.png" width="317" /></a><div class="thumbcaption">A possible placement of some windows: 1 is the root window, which covers the whole screen; 2 and 3 are top-level windows; 4 and 5 are subwindows of 2. The parts of window that are outside its parent are not visible.</div>
       </div>
      </div>
      <p>What is usually called a window in other <!--del_lnk--> graphical user interfaces is a <i>top-level window</i> in the X Window System. The term <i>window</i> is also used for windows that lie within another window, that is, the <i>subwindows</i> of a <i>parent window</i>. Graphical elements such as buttons, menus, icons, etc. are all realized using windows.<p>A window can only be created as a subwindow of a parent window. This makes the windows to be arranged in a <!--del_lnk--> tree, that is, a <!--del_lnk--> hierarchy. The root of this hierarchy is called the <!--del_lnk--> root window, which is automatically created by the server. The top-level windows are exactly the direct subwindows of the root window. Visibly, the root window is as large as the screen, and lies behind all other windows.<p><a id="Identifiers" name="Identifiers"></a><h3> <span class="mw-headline">Identifiers</span></h3>
      <p>All data about windows, fonts, etc. is stored in the server. The client knows identifiers of these objects&mdash;integers it can use as names for them when interacting with the server. For example, if a client wishes a window to be created, it requests the server to create a window with a given identifier. The server creates a window and associates it with the identifier. The identifier can be later used by the client to request, for example, a string to be drawn in the window.<p>Identifiers are unique to the server, not only to the client; for example, no two windows have the same identifier, even if created by two different clients. A client can access any object given its identifier, even if the object has been created by another client.<p><a id="Attributes_and_properties" name="Attributes_and_properties"></a><h3> <span class="mw-headline">Attributes and properties</span></h3>
      <p>Every window has a predefined set of attributes and a set of properties, all stored in the server and accessible to the clients via appropriate requests. Attributes are data about the window, such as its size, position, background colour, etc. Properties are pieces of data that are attached to a window. Contrary to attributes, properties have no meaning at the level of the X Window core protocol. A client can store arbitrary data in a property of a window.<p>A property is characterized by a name, a type, and a value. Properties are similar to <!--del_lnk--> variables in <!--del_lnk--> imperative programming languages, in that the application can create a new property with a given name and of a given type and store a value in it. Properties are associated to windows: two properties with the same name can exist on two different windows while having different types and values.<p>Properties are mostly used for inter-client communication. For example, the property named <code>WM_NAME</code> is used for storing the name for the window; window managers typically read this property and display the name of the window at the top of it.<p>The properties of a window can be shown using the <code>xprop</code> program. In particular, <code>xprop -root</code> shows the properties of the root window, which include the <!--del_lnk--> X resources (parameters of programs).<p><a id="Events" name="Events"></a><h3> <span class="mw-headline">Events</span></h3>
      <p>Events are packets sent by the server to the client to communicate that something the client may be interested in has happened. A client can request the server to send an event to another client; this is used for communication between clients. For example, when a client requests the text that is currently selected, an event is sent to the client that is currently handling the window that holds the selection.<p>The content of a window may be destroyed in some conditions (for example, if the window is covered). Whenever an area of destroyed content is made visible, the server generates an <code>Expose</code> event to notify the client that a part of the window has to be drawn.<p>Other events are used to notify clients of keyboard or mouse input, of the creation of new windows, etc.<p>Some kinds of events are always sent to client, but most kinds of event are sent only if the client previously stated an interest in them. This is because clients may only be interested in some kind of events. For example, a client may be interested in keyboard-related event but not in mouse-related events.<p><a id="Color_modes" name="Color_modes"></a><h3> <span class="mw-headline">Colour modes</span></h3>
      <p>The way colors are handled in the X Window Systems sometimes confuse users, and historically several different modes has been supported. Most modern applications use <!--del_lnk--> TrueColor (24-bit color, 8 bits for each of red, green and blue), but old or specialist applications may require a different colour mode. Many commercial specialist applications use PseudoColor.<p>The X11 protocol actually uses a single 32-bit unsigned integer for representing a single colour in most graphic operations, called a <i>pixelvalue</i>. When transferring <!--del_lnk--> primary colors intensity, a 16 bits integer is used for each colour component. The following representations of colors exist; not all of them may be supported on a specific device.<ul>
       <li><b>DirectColor:</b> A pixel value is decomposed into separate red, green, and blue subfields. Each subfield indexes a separate colormap. Entries in all colormaps can be changed. <ul>
         <li><b>TrueColor:</b> Same as DirectColor, except that the colormap entries are predefined by the hardware and cannot be changed. Typically, each of the red, green, and blue colormaps provides a (near) linear ramp of intensity.</ul>
       <li><b>GrayScale:</b> A pixel value indexes a single colormap that contains monochrome intensities. Colormap entries can be changed. <ul>
         <li><b>StaticGray:</b> Same as GrayScale, except that the colormap entries are predefined by the hardware and cannot be changed.</ul>
       <li><b>PseudoColor</b> (<!--del_lnk--> Chunky): A pixel value indexes a single colormap that contains colour intensities. Colormap entries can be changed. <ul>
         <li><b>StaticColor:</b> Same as PseudoColor, except that the colormap entries are predefined by the hardware and cannot be changed.</ul>
      </ul>
      <p><a id="Xlib_and_other_client_libraries" name="Xlib_and_other_client_libraries"></a><h2> <span class="mw-headline">Xlib and other client libraries</span></h2>
      <dl>
       <dd>
      </dl>
      <p>Most client programs communicate with the server via the <!--del_lnk--> Xlib client library. In particular, most clients use libraries such as <!--del_lnk--> Xaw, <!--del_lnk--> Motif, <!--del_lnk--> GTK+, or <!--del_lnk--> Qt which in turn use <!--del_lnk--> Xlib for interacting with the server.<p><a id="Inter-client_communication" name="Inter-client_communication"></a><h2> <span class="mw-headline">Inter-client communication</span></h2>
      <p>The X Window core protocol provides mechanisms for communication between clients: window properties and events, in particular the client-to-client message events. However, it does not specify any protocol for such interactions. These protocols are instead governed by a separate set of inter-client communication conventions.<p>The <!--del_lnk--> Inter-Client Communication Conventions Manual specifies the protocol for the exchange of data via selections and the interaction of applications with the window manager. This specification has been considered difficult and confusing; consistency of application <!--del_lnk--> look and feel and communication is typically addressed by programming to a given desktop environment.<p>The Inter-Client Exchange protocol (ICE) specifies a framework for building protocols for interaction between clients, so that a specific protocol can be built at the top of it. In particular, the X Session Management protocol (XSMP) is a protocol based on ICE that mandates over the interaction between applications with the <!--del_lnk--> session manager, which is the program that takes care of storing the status of the desktop at the end of an interactive session and recovering it when another session with the same user is started again.<p>Newer conventions are included in the <!--del_lnk--> freedesktop specifications, including the drag-and-drop convention Xdnd used for transferring data by selecting it and dragging in another window and the embedded application convention Xembed which details how an application can be run in a subwindow of another application.<p><a id="Selections.2C_cut_buffers.2C_and_drag-and-drop" name="Selections.2C_cut_buffers.2C_and_drag-and-drop"></a><h3> <span class="mw-headline">Selections, cut buffers, and drag-and-drop</span></h3>
      <dl>
       <dd>
      </dl>
      <p>Selections, cut buffers, and drag-and-drop are the mechanisms used in the X Window System to allow a user to transfer data from a window to another. Selections and cut buffer are used (typically) when a user selects text or some other data in a window and paste in another one. Drag-and-drop is used when a user selects something in a window, then clicks on the selection and drags it into another window.<p>Since the two windows may be handled by two different applications, data transfer requires two different clients connected with the same X server to interact. The X Window core protocol includes some types of requests and events that are specific to selection exchange, but the transfer is mainly done using the general client-to-client event sending and window properties, which are not specific to selection transfer.<p>Data to be transferred between clients can be of different types: it is usually text, but can also be a pixmap, a number, a list of objects, etc.<p>Selections and drag-and-drop are active mechanisms: after some text has been selected in a window, the client handling the window must actively support a protocol for transferring the data to the application requesting it. On the contrary, cut buffers are a passive mechanism: when the user selects some text, its content is transferred to a cut buffer, where it remains even if the application handling the window terminates and the window is destroyed.<p><a id="Window_manager" name="Window_manager"></a><h3> <span class="mw-headline">Window manager</span></h3>
      <dl>
       <dd>
      </dl>
      <p>A window manager is a program that controls the general appearance of windows and other graphical elements of the <!--del_lnk--> graphical user interface. Differences in the look of X Window System in different installations is mainly due to the use of different window managers or different configurations of the window manager.<p>The window manager takes care of deciding the position of windows, placing the decorative border around them, handling icons, handling mouse clicks outside windows (on the &ldquo;background&rdquo;), handling certain keystrokes (for example, iconifying a window when ALT-F4 is pressed), etc.<p>From the point of view of the X server, the window manager is not different from the other clients. The initial position and the decorative borders around windows are handled by the window manager using the following requests:<ol>
       <li>an application can request the server not to satisfy requests of mapping (showing) subwindows of a given window, and to be sent an event instead;<li>an application can request changing the parent of a window.</ol>
      <p>The window manager uses the first request to intercept any request for mapping top-level windows (children of the root window). Whenever another application requests the mapping of a top-level window, the server does not do it but sends an event to the window manager instead. Most window managers <!--del_lnk--> reparents the window: they create a larger top-level window (called the frame window) and reparent the original window as a child of it. Graphically, this corresponds to placing the original window inside the frame window. The space of the frame window that is not taken by the original window is used for the decorative frame around the window (the &ldquo;border&rdquo; and the &ldquo;title bar&rdquo;).<p>The window manager manages mouse clicks in the frame window. This allows for example to move or resize the window when the user clicks and drags on the border or on the title bar.<p>The window manager is also responsible for the handling of icons and related visual elements of the graphical user interface. Icons do not exist at the level of the X Window core protocol. They are implemented by the window manager. For example, whenever a window has to be &ldquo;iconified&rdquo;, the window manager <!--del_lnk--> FVWM unmaps the window, making it not visible, and creates a window for the icon name and possibly another window for the icon image. The meaning and handling of icons is therefore completely decided by the window manager: some window managers such as <!--del_lnk--> wm2 do not implement icons at all.<p><a id="Session_manager" name="Session_manager"></a><h3> <span class="mw-headline">Session manager</span></h3>
      <dl>
       <dd>
      </dl>
      <p>Roughly, the state of a <!--del_lnk--> session is the &ldquo;state of the desktop&rdquo; at a given time: a set of windows with their current content. More precisely, it is the set of applications managing these windows and the information that allow these applications to restore the condition of their managed windows if required. An X session manager is a program that saves and restore the state of sessions.<p>The most recognizable effect of using a session manager is the possibility of logging out from an interactive session and then finding exactly the same windows in the same state when logging in again. For this to work, the session manager program stores the names of the running applications at logout and starts them again at login. In order for the state of the applications to be restored as well (which is needed to restore the content of windows), the applications must be able to save their state of execution upon request from the session manager and load it back when they start again.<p>The X Window System include a default session manager called <code>xsm</code>. Other session managers have been developed for specific desktop systems: for example, <code>ksmserver</code> is the default session manager of <!--del_lnk--> KDE.<p><a id="X_display_manager" name="X_display_manager"></a><h2> <span class="mw-headline">X display manager</span></h2>
      <dl>
       <dd>
      </dl>
      <p>The <!--del_lnk--> X display manager is the program that shows the graphical login prompt in the X Window System. More generally, a display manager runs one or more X servers on the local computer and accepts incoming connections from X servers running on remote computers. The local servers are started by the display manager, which then connects to them to present the user the login screen. The remote servers are started independently from the display manager and connect to it. In this situation, the display manager works like a graphical <!--del_lnk--> telnet server: an X server can connect to the display manager, which starts a session; the programs of this sessions run on the same computer of the display manager but have input and output on the computer where the X server runs (which is the computer in front of the user).<p><!--del_lnk--> XDM is the basic display manager supplied with the X Window System. Other display manager include <!--del_lnk--> GDM (<a href="../../wp/g/GNOME.htm" title="GNOME">GNOME</a>), <!--del_lnk--> KDM (<!--del_lnk--> KDE), <!--del_lnk--> WDM (using the WINGs widget set used in <!--del_lnk--> Window Maker) and <!--del_lnk--> entrance (using the architecture used in <!--del_lnk--> Enlightenment v.17).<p><a id="User_interface_elements" name="User_interface_elements"></a><h2> <span class="mw-headline">User interface elements</span></h2>
      <p>Early <!--del_lnk--> widget toolkits for X included <!--del_lnk--> Xaw (the <!--del_lnk--> Athena Widget Set), <!--del_lnk--> OLIT (OPEN LOOK Intrinsics Toolkit), <!--del_lnk--> XView, <!--del_lnk--> Motif and <!--del_lnk--> Tk. OLIT and XView function as the base toolkits for <a href="../../wp/a/AT%2526T.htm" title="AT&amp;T">AT&amp;T</a> and <!--del_lnk--> Sun&#39;s <!--del_lnk--> OPEN LOOK GUI.<p>Motif provides the base toolkit for the <!--del_lnk--> Common Desktop Environment (CDE), which is the standard <!--del_lnk--> desktop environment used on commercial <a href="../../wp/u/Unix.htm" title="Unix">Unix</a> systems such as <!--del_lnk--> Solaris and <!--del_lnk--> HP-UX. (<a href="../../wp/g/GNOME.htm" title="GNOME">GNOME</a> is offered in Solaris 9 and will be standard in future versions.)<p>More modern toolkits include <!--del_lnk--> Qt (used by <!--del_lnk--> KDE), <!--del_lnk--> GTK+ (used by <a href="../../wp/g/GNOME.htm" title="GNOME">GNOME</a>), <!--del_lnk--> wxWidgets, <!--del_lnk--> FLTK and <!--del_lnk--> FOX.<p><a id="Extensions" name="Extensions"></a><h2> <span class="mw-headline">Extensions</span></h2>
      <p>The X server was designed to be simple but extensible. As such, much functionality now resides in extensions to the protocol. The following is a partial list of extensions that have been developed, sorted roughly by recency of introduction:<ul>
       <li><!--del_lnk--> AIGLX<li>Composite<li>Damage<li><!--del_lnk--> XFixes<li>Extended-Visual-Information (EvIE)<li>Dual Multihead (DMX)<li><!--del_lnk--> XvMC, video with motion compensation<li><!--del_lnk--> GLX<li><!--del_lnk--> XRender<li>Resize and Rotate (RANDR)<li><!--del_lnk--> Xinerama<li>Display Power Management Signaling (DPMS)<li>XPRINT<li>Low Bandwidth Extension (LBX, obsolete)<li><!--del_lnk--> X keyboard extension<li>DOUBLE-BUFFER<li>RECORD<li>XImage Extension (obsolete)<li><!--del_lnk--> MIT-SHM<li>SYNC<li>XTEST<li>XInputExtension<li>BIG-REQUESTS<li>XC-MISC<li><!--del_lnk--> X video extension, also called Xv (not to be confused with the <!--del_lnk--> xv program)<li>PEX (obsolete)<li><!--del_lnk--> Shape<li>DEC-XTRAP<li>MIT-SCREEN-SAVER<li>MIT-SUNDRY-NONSTANDARD<li>SECURITY<li>TOG-CUP<li>X-Resource<li>XC-APPGROUP<li>XFree86-Bigfont<li>XFree86-DGA<li>XFree86-Misc<li>XFree86-VidModeExtension</ul>
      <p>At the protocol level, every extension can be assigned new request/event/error packet types. Access to client applications to the functionalities provided by extensions is facilitated by client libraries. The coding of extensions into the current X server implementations is reportedly difficult due to a lack of modularity in the server design. It is a long term goal of the <!--del_lnk--> XCB project to automate generating both the client and server sides of extensions from XML protocol descriptions.<p><a id="See_also" name="See_also"></a><div class="printfooter"> Retrieved from &quot;<!--del_lnk--> http://en.wikipedia.org/wiki/X_Window_System_protocols_and_architecture&quot;</div>
      <!-- end content -->
      <div class="visualClear">
      </div>
     </div>
    </div>
   </div>
   <!-- end of the left (by default at least) column -->
   <div class="visualClear">
   </div>
   <div id="footer">
    <div class="center"> This reference article is mainly selected from the English Wikipedia with only minor checks and changes (see www.wikipedia.org for details of authors and sources) and is available under the <nobr><a href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm">GNU Free Documentation License</a></nobr>. See also our <b><a href="../../disclaimer.htm">Disclaimer</a></b>. </div>
   </div>
   <script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
  </div>
  
 </body>
</html>
