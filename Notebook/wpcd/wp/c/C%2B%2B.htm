<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html dir="ltr" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <meta content="C++,2003,2006,ABCL/c+,ALGOL 68,Abstraction (computer science),Ada programming language,Algorithm,American National Standards Institute,Andrei Alexandrescu,April 15" name="keywords" />
  <link href="../../favicon.ico" rel="shortcut icon" />
  <link href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm" rel="copyright" />
  <title>C++</title>
  <style media="screen,projection" type="text/css">/*<![CDATA[*/ @import "../../css/wp-monobook-main.css"; /*]]>*/</style>
  <link href="../../css/wp-commonPrint.css" media="print" rel="stylesheet" type="text/css" />
  <!--[if lt IE 5.5000]><style type="text/css">@import "../../css/IE50Fixes.css";</style><![endif]-->
  <!--[if IE 5.5000]><style type="text/css">@import "../../css/IE55Fixes.css";</style><![endif]-->
  <!--[if IE 6]><style type="text/css">@import "../../css/IE60Fixes.css";</style><![endif]-->
  <!--[if IE 7]><style type="text/css">@import "../../css/IE70Fixes.css";</style><![endif]-->
  <!--[if lt IE 7]><script type="text/javascript" src="../../js/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
  <script type="text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";
                        
			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "C++";
			var wgTitle = "C++";
			var wgArticleId = 72038;
			var wgIsArticle = true;
                        
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
  <script src="../../js/wikibits.js" type="text/javascript"><!-- wikibits js --></script>
  <script src="../../js/wp.js" type="text/javascript"><!-- site js --></script>
  <style type="text/css">/*<![CDATA[*/
@import "../../css/wp-common.css";
@import "../../css/wp-monobook.css";
@import "../../css/wp.css";
/*]]>*/</style>
  <!-- Head Scripts -->
 </head>
 <body class="mediawiki ns-0 ltr page-C">
  <div id="globalWrapper">
   <div id="column-content">
    <div id="content"><a id="top" name="top"></a><h1 class="firstHeading">C++</h1>
     <div id="bodyContent">
      <h3 id="siteSub"><a href="../../index.htm">2007 Schools Wikipedia Selection</a>. Related subjects: <a href="../index/subject.IT.Computer_Programming.htm">Computer Programming</a></h3>
      <!-- start content -->
      <table class="infobox" style="width: 23em; text-align: left;font-size: 90%">
       <caption><big><b>C++</b></big></caption>
       <tr>
        <td colspan="2" style="text-align: center;"><!--del_lnk--> <img alt="Image:C plus plus book.jpg" height="160" longdesc="/wiki/Image:C_plus_plus_book.jpg" src="../../images/1x1white.gif" title="This image is not present because of licensing restrictions" width="128" /></td>
       </tr>
       <tr>
        <th><!--del_lnk--> Paradigm:</th>
        <td><!--del_lnk--> multi-paradigm: <!--del_lnk--> generic-programming language with a bias towards systems programming, <!--del_lnk--> object-oriented, <!--del_lnk--> procedural</td>
       </tr>
       <tr>
        <th>Appeared in:</th>
        <td>1985, last revised 2003</td>
       </tr>
       <tr>
        <th>Designed by:</th>
        <td><!--del_lnk--> Bjarne Stroustrup</td>
       </tr>
       <tr>
        <th><!--del_lnk--> Typing discipline:</th>
        <td><!--del_lnk--> static, <!--del_lnk--> unsafe, <!--del_lnk--> nominative</td>
       </tr>
       <tr>
        <th>Major implementations:</th>
        <td><!--del_lnk--> GNU Compiler Collection, <!--del_lnk--> Microsoft Visual C++, <!--del_lnk--> Borland C++ Builder</td>
       </tr>
       <tr>
        <th>Dialects:</th>
        <td><!--del_lnk--> ANSI C++ 1998, ANSI C++ 2003</td>
       </tr>
       <tr>
        <th>Influenced by:</th>
        <td><!--del_lnk--> C, <!--del_lnk--> Simula, <!--del_lnk--> Ada 83, <!--del_lnk--> ALGOL 68, <!--del_lnk--> CLU, <!--del_lnk--> ML</td>
       </tr>
       <tr>
        <th>Influenced:</th>
        <td><!--del_lnk--> Ada 95, <!--del_lnk--> C#, <!--del_lnk--> Java, <!--del_lnk--> PHP, <!--del_lnk--> D</td>
       </tr>
       <tr>
        <td>
        </td>
       </tr>
      </table>
      <p><b>C++</b> (generally pronounced <span class="IPA" title="Pronunciation in IPA">/si pl&#x28C;s pl&#x28C;s/</span>) is a general-purpose, <!--del_lnk--> high-level <a href="../../wp/p/Programming_language.htm" title="Programming language">programming language</a> with <!--del_lnk--> low-level facilities. It is a <!--del_lnk--> statically typed <!--del_lnk--> free-form <!--del_lnk--> multi-paradigm language supporting <!--del_lnk--> procedural programming, <!--del_lnk--> data abstraction, <!--del_lnk--> object-oriented programming, and <!--del_lnk--> generic programming. Since the 1990s, C++ has been one of the most popular commercial programming languages.<p><!--del_lnk--> Bjarne Stroustrup developed C++ (originally named &quot;<i>C with Classes</i>&quot;) in 1983 at <!--del_lnk--> Bell Labs as an enhancement to the <!--del_lnk--> C programming language. Enhancements started with the addition of <!--del_lnk--> classes, followed by, among other features, <!--del_lnk--> virtual functions, <!--del_lnk--> operator overloading, <!--del_lnk--> multiple inheritance, <!--del_lnk--> templates, and <!--del_lnk--> exception handling. The C++ programming language standard was ratified in 1998 as <i><!--del_lnk--> ISO/IEC 14882:1998</i>, the current version of which is the 2003 version, <i>ISO/IEC 14882:2003</i>. A new version of the standard (known informally as <b><!--del_lnk--> C++0x</b>) is being developed.<p>
       <script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script><a id="History" name="History"></a><h2> <span class="mw-headline">History</span></h2>
      <p>Stroustrup began work on <i>C with Classes</i> in 1979. The idea of creating a new language originated from Stroustrup&#39;s experience in programming for his Ph.D. thesis. Stroustrup found that <!--del_lnk--> Simula had features that were very helpful for large software development, but the language was too slow for practical use, while <!--del_lnk--> BCPL was fast but too low-level and unsuitable for large software development. When Stroustrup started working in <!--del_lnk--> Bell Labs, he had the problem of analyzing the <a href="../../wp/u/Unix.htm" title="Unix">UNIX</a> <!--del_lnk--> kernel with respect to <!--del_lnk--> distributed computing. Remembering his Ph.D. experience, Stroustrup set out to enhance the C language with Simula-like features. C was chosen because it is general-purpose, fast, and portable. Besides <!--del_lnk--> C and <!--del_lnk--> Simula, some other languages which inspired him were <!--del_lnk--> ALGOL 68, <!--del_lnk--> Ada, <!--del_lnk--> CLU and <!--del_lnk--> ML. At first, the class, derived class, strong type checking, inlining, and default argument features were added to C via <!--del_lnk--> Cfront. The first commercial release occurred in October 1985.<p>In 1983, the name of the language was changed from C with Classes to C++. New features were added including virtual functions, function name and operator overloading, references, constants, user-controlled free-store memory control, improved type checking, and a new single-line comment style with two forward slashes (//). In 1985, the first edition of <i>The C++ Programming Language</i> was released, providing an important reference to the language, as there was not yet an official standard. In 1989, Release 2.0 of C++ was released. New features included multiple inheritance, abstract classes, static member functions, <!--del_lnk--> const member functions, and protected members. In 1990, <i>The Annotated C++ Reference Manual</i> was published. This work became the basis for the future standard. Late addition of features included <!--del_lnk--> templates, <!--del_lnk--> exceptions, <!--del_lnk--> namespaces, new <!--del_lnk--> casts, and a <!--del_lnk--> Boolean type.<p>As the C++ language evolved, a standard library also evolved with it. The first addition to the C++ standard library was the stream I/O library which provided facilities to replace the traditional C functions such as <!--del_lnk--> printf and <!--del_lnk--> scanf. Later, among the most significant additions to the standard library, was the <!--del_lnk--> Standard Template Library.<p>After years of work, a joint <!--del_lnk--> ANSI-<!--del_lnk--> ISO committee standardized C++ in 1998 (<i><!--del_lnk--> ISO/IEC 14882:1998</i>). For some years after the official release of the standard in 1998, the committee processed defect reports, and published a corrected version of the C++ standard in 2003. In 2005, a technical report, called the &quot;<!--del_lnk--> Library Technical Report 1&quot; (often known as TR1 for short) was released. While not an official part of the standard, it gives a number of extensions to the standard library which are expected to be included in the next version of C++. Support for TR1 is growing in almost all currently maintained C++ compilers.<p>While the C++ language is royalty-free, the standard document itself is not freely available.<p><a id="The_name_.22C.2B.2B.22" name="The_name_.22C.2B.2B.22"></a><h3> <span class="mw-headline">The name &quot;C++&quot;</span></h3>
      <p>This name is credited to <!--del_lnk--> Rick Mascitti (mid-1983) and was first used in December 1983. Earlier, during the <!--del_lnk--> research period, the developing language had been referred to as &quot;new C&quot;, then &quot;<!--del_lnk--> C with <!--del_lnk--> Classes&quot;. The final name stems from C&#39;s &quot;++&quot; <!--del_lnk--> operator (which increments the <!--del_lnk--> value of a <!--del_lnk--> variable) and a common <!--del_lnk--> naming convention of using &quot;+&quot; to indicate an enhanced computer program. According to Stroustrup: &quot;the name signifies the <a href="../../wp/e/Evolution.htm" title="Evolution">evolutionary</a> nature of the changes from C&quot;. <!--del_lnk--> C+ was the name of an earlier, unrelated programming language.<p>Stroustrup addressed the origin of the name in the <!--del_lnk--> preface of later editions of his book, <i><!--del_lnk--> The C++ Programming Language</i>, adding that &quot;C++&quot; might be inferred from the appendix of <!--del_lnk--> George Orwell&#39;s <i><a href="../../wp/n/Nineteen_Eighty-Four.htm" title="Nineteen Eighty-Four">Nineteen Eighty-Four</a></i>. Of the three segments of the fictional language <!--del_lnk--> Newspeak, the &quot;C vocabulary&quot; is the one dedicated to technical terms and <!--del_lnk--> jargon. &quot;Doubleplus&quot; is the <!--del_lnk--> superlative modifier for Newspeak adjectives. Thus, &quot;C++&quot; might hold the meaning &quot;most extremely technical or jargonous&quot; in Newspeak.<p>When <!--del_lnk--> Rick Mascitti was questioned informally in 1992 about the naming, he indicated that it was given in a <!--del_lnk--> tongue-in-cheek spirit. He never thought that it would become the formal name of the language.<p><a id="Future_development" name="Future_development"></a><h3> <span class="mw-headline">Future development</span></h3>
      <p>C++ continues to evolve to meet future requirements. One group in particular, <!--del_lnk--> Boost.org, works to make the most of C++ in its current form and advises the C++ standards committee as to which features work well and which need improving. Current work indicates that C++ will capitalize on its multi-paradigm nature more and more. The work at Boost, for example, is greatly expanding C++&#39;s functional and <!--del_lnk--> metaprogramming capabilities. A new version of the C++ standard is currently being worked on, entitled <!--del_lnk--> &quot;C++0X&quot; (denoting the fact it is expected to be released before 2010) which will include a number of new features.<p><a id="Philosophy" name="Philosophy"></a><h2> <span class="mw-headline">Philosophy</span></h2>
      <p>In <i><!--del_lnk--> The Design and Evolution of C++</i> (1994), Bjarne Stroustrup describes some rules that he uses for the design of C++. Knowing the rules helps to understand why C++ is the way it is. The following is a summary of the rules. Much more detail can be found in <i>The Design and Evolution of C++</i>.<ul>
       <li>C++ is designed to be a <!--del_lnk--> statically typed, general-purpose language that is as efficient and portable as C<li>C++ is designed to directly and comprehensively support multiple programming styles (<!--del_lnk--> procedural programming, <!--del_lnk--> data abstraction, <!--del_lnk--> object-oriented programming, and <!--del_lnk--> generic programming)<li>C++ is designed to give the programmer choice, even if this makes it possible for the programmer to choose incorrectly<li>C++ is designed to be as compatible with C as possible, therefore providing a smooth transition from C<li>C++ avoids features that are platform specific or not general purpose<li>C++ does not incur overhead for features that are not used<li>C++ is designed to function without a sophisticated programming environment</ul>
      <p>Stanley B. Lippman describes various models in his in-depth book <i>&quot;Inside the C++ Object Model&quot;</i> (1996) for how compilers may convert C++ program statements into an in-memory layout. Compiler vendors are free to implement the standard in their own manner. Lippman worked on implementing and maintaining <i>C-front</i>, the original C++ implementation at Bell Labs.<p><a id="Standard_library" name="Standard_library"></a><h2> <span class="mw-headline">Standard library</span></h2>
      <p>The 1998 C++ <!--del_lnk--> standard consists of two parts: the <!--del_lnk--> core language and the <!--del_lnk--> C++ standard library; the latter includes most of the <!--del_lnk--> Standard Template Library and a slightly modified version of the C standard library. Many C++ libraries exist which are not part of the standard, and, using external linkage, libraries can even be written in <!--del_lnk--> C.<p>The <!--del_lnk--> C++ standard library incorporates the C standard library with some small modifications to make it work better with the C++ language. Another large part of the C++ library is based on the <!--del_lnk--> Standard Template Library (STL). This provides such useful tools as <!--del_lnk--> containers (for example <!--del_lnk--> vectors and <!--del_lnk--> lists), <!--del_lnk--> iterators (generalized <!--del_lnk--> pointers) to provide these containers with array-like access and <a href="../../wp/a/Algorithm.htm" title="Algorithm">algorithms</a> to perform operations such as searching and sorting. Furthermore (multi)maps (<!--del_lnk--> associative arrays) and (multi)sets are provided, all of which export compatible interfaces. Therefore it is possible, using templates, to write generic algorithms that work with any container or on any sequence defined by iterators. As in C, the <!--del_lnk--> features of the <a href="../../wp/l/Library.htm" title="Library">library</a> are accessed by using the <code>#include</code> <!--del_lnk--> directive to include a <!--del_lnk--> standard header. C++ provides sixty-nine standard headers, of which nineteen are deprecated.<p>Using the standard library--for example, using std::vector or std::string instead of a C-style array--can help lead to safer and more scalable software.<p>The <!--del_lnk--> STL was originally a third-party library from <!--del_lnk--> HP and later <!--del_lnk--> SGI, before its incorporation into the C++ standard. The standard does not refer to it as &quot;STL&quot;, as it is merely a part of the standard library, but many people still use that term to distinguish it from the rest of the library (input/output streams, internationalization, diagnostics, the C library subset, etc.).<p>Most C++ compilers provide an implementation of the C++ standard library, including the STL. Compiler-independent implementations of the STL, such as <!--del_lnk--> STLPort, also exist. Other projects also produce various custom implementations of the C++ standard library and the STL with various design goals.<p><a id="Features_introduced_in_C.2B.2B" name="Features_introduced_in_C.2B.2B"></a><h2> <span class="mw-headline">Features introduced in C++</span></h2>
      <p>Compared to the C language, C++ introduced extra features, including <!--del_lnk--> declarations as statements, function-like casts, <code><!--del_lnk--> new</code>/<code><!--del_lnk--> delete</code>, <code>bool</code>, <!--del_lnk--> reference types, <code>inline</code> functions, default arguments, function overloading, <!--del_lnk--> namespaces, classes (including all class-related features such as inheritance, member functions, virtual functions, abstract classes, and constructors), operator overloading, <!--del_lnk--> templates, the <code>::</code> operator, exception handling, and runtime <!--del_lnk--> type identification.<p>Contrary to popular belief, C++ did not introduce the <!--del_lnk--> <code>const</code> keyword first. Const was formally added to C shortly before it was adopted by C++.<p>C++ also performs more type checking than C in several cases (see &quot;Incompatibility with C&quot; below).<p>Comments starting with two slashes (&quot;<code>//</code>&quot;) were originally part of <!--del_lnk--> C&#39;s predecessor, <!--del_lnk--> BCPL, and were reintroduced in C++.<p>Several features of C++ were later adopted by C, including declarations in <code>for</code> loops, C++-style comments (using the <code>//</code> symbol), and <code>inline</code>, though the C99 definition of the <code>inline</code> keyword is not compatible with its C++ definition. However, <!--del_lnk--> C99 also introduced features that do not exist in C++, such as <!--del_lnk--> variadic macros and better handling of arrays as parameters; some C++ compilers may implement some of these features as extensions, but others are incompatible with existing C++ features.<p>A very common source of confusion is a subtle terminology issue: because of its derivation from C, in C++ the term <i>object</i> means <i>memory area</i>, just like in C, and not <i>class instance</i>, which is what it means in most other <!--del_lnk--> object oriented languages. For example, in both C and C++, the statement <code>int i;</code> defines an object of type <code>int</code>, that is the memory area where the value of the variable <code>i</code> will be stored on assignment.<p><a id="Incompatibility_with_C" name="Incompatibility_with_C"></a><h2> <span class="mw-headline">Incompatibility with C</span></h2>
      <p>C++ is often considered to be a superset of C, but this is not strictly true. Most C code can easily be made to compile correctly in C++, but there are a few differences that cause some valid C code to be invalid in C++, or to behave differently in C++.<p>Perhaps the most commonly encountered difference is that C allows implicit conversion from <code>void*</code> to other pointer types, but C++ does not. So, the following is valid C code:<pre>
int *i = malloc(sizeof(int) * 5);     /* Implicit conversion from void* to int* */
</pre><p>but to make it work in <i>both</i> C and C++ one would need to use an explicit cast:<pre>
int *i = (int *) malloc(sizeof(int) * 5);
</pre><p>Another common portability issue is that C++ defines many new keywords, such as <code>new</code> and <code>class</code>, that may be used as identifiers (e.g. variable names) in a C program.<p>Some incompatibilities have been removed by the latest (C99) C standard, which now supports C++ features such as <code>//</code> comments and mixed declarations and code. However, C99 introduced a number of new features that conflict with C++ (such as variable-length arrays, native complex-number types, and compound literals), so the languages may be diverging more than they are converging.<p>In order to intermix C and C++ code, any C code which is to be called from/used in C++ must be put in <code>extern &quot;C&quot; { /* C code */ }</code>.<h2> <span class="mw-headline">Language features</span></h2>
      <p><a id="Operators" name="Operators"></a><h3> <span class="mw-headline">Operators</span></h3>
      <dl>
       <dd>
      </dl>
      <p>1. logical 2. releational 3. unary<p><a id="Preprocessor" name="Preprocessor"></a><h3> <span class="mw-headline">Preprocessor</span></h3>
      <p>C++ is principally compiled in three phases: preprocessing, translation to object code, and linking (the two last phases are what is generally thought of as the &quot;compilation&quot; proper). In the first phase, preprocessing, <i>preprocessor directives</i> apply lexical transformations to the source code, which is then fed to the next compilation stage.<p><a id="Preprocessor_directives_and_macros" name="Preprocessor_directives_and_macros"></a><h4> <span class="mw-headline">Preprocessor directives and macros</span></h4>
      <p>Pre-processing directives work by simple substitution of tokenized character sequences for other tokenized character sequences, according to user-defined rules. They typically perform <!--del_lnk--> macro substitution, inclusion of other files (by opposition to higher-order features such as inclusion of modules/packages/units/components), conditional compilation and/or conditional inclusion. For instance:<pre>
#define PI 3.1415926535897932384626433832795
</pre><p>Every time <code>PI</code> appears in the source code it will be replaced with <code>3.1415926535897932384626433832795</code>. Another common example is<pre>
#include &lt;iostream&gt;
</pre><p>which includes (imports) all symbols from the standard library header file <code>iostream</code>. In addition to the most common directives mentioned above, there are several additional preprocessor directives that control the flow of compilation, conditionally include or exclude code blocks, and control various other aspects of compilation.<p><a id="Templates" name="Templates"></a><h3> <span class="mw-headline">Templates</span></h3>
      <p>Templates are different from macros: while both of these compile-time language features can be used to produce conditional compilation, templates are not restricted to lexical substitution. Templates have an awareness of the semantics and type system of their companion language as well as all compile-time type definitions and can perform high-level operations including programmatic flow control based on evaluation of strictly type-checked parameters. Macros are capable of conditional control over compilation based on predetermined criteria but cannot instantiate new types, recurse or perform type evaluation and in effect are limited to pre-compilation text-substitution and text-inclusion/exclusion. In other words, macros can control compilation flow based on pre-defined symbols but cannot, unlike templates, independently instantiate new symbols. Templates are a tool for static <!--del_lnk--> polymorphism (see below) and <!--del_lnk--> generic programming. For example, a template replacing the common, but dangerous, macro <code>#define max(x,y) ((x)&gt;(y)?(x):(y))</code>:<pre>
template &lt;typename T&gt;
T max(T x, T y)
{
    if (x &lt; y)
        return y;
    else
        return x;
}
</pre><p>This can be found in the <code>algorithm</code> header as <code>std::max()</code>.<p>In addition, templates are a compile time mechanism in C++ which is <!--del_lnk--> Turing-complete, meaning that any computation expressible by a computer program can be computed, in some form, by a <!--del_lnk--> template metaprogram prior to runtime.<p><a id="Objects" name="Objects"></a><h3> <span class="mw-headline">Objects</span></h3>
      <p>C++ introduces some <!--del_lnk--> object-oriented (OO) features to C. It offers <!--del_lnk--> classes, which provide the four features commonly present in OO (and some non-OO) languages: <!--del_lnk--> abstraction, <!--del_lnk--> encapsulation, <!--del_lnk--> inheritance and <!--del_lnk--> polymorphism. Objects are set by classes, which are basically like a set of attributes already defined, and can be created at any time.<p><a id="Encapsulation" name="Encapsulation"></a><h4> <span class="mw-headline">Encapsulation</span></h4>
      <p>C++ implements <!--del_lnk--> encapsulation by allowing all members of a class to be declared as either public, private, or protected. A public member of the class will be accessible to any function. A private member will only be accessible to functions that are members of that class and to functions and classes explicitly granted access permission by the class (&quot;friends&quot;). A protected member will be accessible to members of classes that inherit from the class in addition to the class itself and any friends.<p>The OO principle is that all and only the functions that can access the internal representation of a type should be encapsulated within the type definition. C++ supports this (via member functions and friend functions), but does not enforce it: the programmer can declare parts or all of the representation of a type to be public, and is also allowed to make public entities that are not part of the representation of the type. Because of this, C++ supports not just OO programming but other weaker decomposition paradigms, like <!--del_lnk--> modular programming.<p>It is generally considered good practice to make all <!--del_lnk--> data private or protected, and to make public only those functions that are part of a minimal interface for users of the class, that hides implementation details.<p><a id="Inheritance" name="Inheritance"></a><h4> <span class="mw-headline">Inheritance</span></h4>
      <p>Inheritance from a base class may be declared as public, protected, or private. This access specifier determines whether unrelated and derived classes can access the inherited public and protected members of the base class. Only public inheritance corresponds to what is usually meant by &quot;inheritance&quot;. The other two forms are much less frequently used. If the access specifier is omitted, inheritance is assumed to be private for a class base and public for a struct base. Base classes may be declared as virtual; this is called <!--del_lnk--> virtual inheritance. Virtual inheritance ensures that only one instance of a base class exists in the inheritance graph, avoiding some of the ambiguity problems of <!--del_lnk--> multiple inheritance.<p><b><!--del_lnk--> Multiple inheritance</b> is a C++ feature sometimes considered controversial. Multiple inheritance allows a class to be derived from more than one base class; this can result in a complicated graph of inheritance relationships. For example, a &quot;Flying Cat&quot; class can inherit from both &quot;Cat&quot; and &quot;Flying Mammal&quot;. Some other languages, such as <!--del_lnk--> C# or <!--del_lnk--> Java, accomplish something similar (although more limited) by allowing inheritance of multiple <!--del_lnk--> interfaces while restricting the number of base classes to one (interfaces, unlike classes, provide no implementation of function members).<p><a id="Polymorphism" name="Polymorphism"></a><h3> <span class="mw-headline">Polymorphism</span></h3>
      <p>C++ supports several kinds of <b>static</b> (<b><!--del_lnk--> compile-time</b>) and <b>dynamic</b> (<b><!--del_lnk--> run-time</b>) <b><!--del_lnk--> polymorphism</b>. Compile-time polymorphism does not allow for certain run-time decisions, while run-time polymorphism typically incurs more of a performance penalty.<p><b>Static polymorphism</b><dl>
       <dd><b>Function overloading</b></dl>
      <p><b><!--del_lnk--> Function overloading</b> allows programs to declare multiple functions with the same name. The functions are distinguished by the number and/or types of their <!--del_lnk--> formal parameters. Thus, the same function name can refer to different functions depending on the context in which it is used.<dl>
       <dd><b>Operator overloading</b></dl>
      <p>Similarly, <b><!--del_lnk--> operator overloading</b> allows programs to define certain operators (such as <code>+</code>, <code>!=</code>, <code>&lt;</code>, or <code>&amp;</code>) to result in a function call that depends on the types of the operands they are used on.<dl>
       <dd><b>Class and function templates</b></dl>
      <p><b><!--del_lnk--> Templates</b> in C++ provide a sophisticated mechanism for writing generic, polymorphic code. In particular, through the <i><!--del_lnk--> Curiously Recurring Template Pattern</i> it&#39;s possible to implement a form of static polymorphism that closely mimics the syntax for overriding virtual methods (a dynamic polymorphism technique described below). Since C++ templates are type-aware and <!--del_lnk--> Turing-complete they can also be used to let the compiler resolve recursive conditionals and generate substantial programs through <!--del_lnk--> template metaprogramming.<p><b>Dynamic polymorphism</b><dl>
       <dd><b>Polymorphism through inheritance</b></dl>
      <p>Variable pointers (and references) of a base class type in C++ can refer to objects of any derived classes of that type in addition to objects exactly matching the variable type. This allows arrays or other containers of a given type of object to hold pointers to multiple types of objects, which cannot be done otherwise in C++. Because assignment of values to variables usually occurs at run-time, this is necessarily a run-time phenomenon.<p>C++ also provides a <code>dynamic_cast</code> operator, which allows the program to safely attempt conversion of an object into an object of a more specific object type (as opposed to conversion to a more general type, which is always allowed). This feature relies on <!--del_lnk--> run-time type information (RTTI). Objects known to be of a certain specific type can also be cast to that type with <code>static_cast</code>, a purely compile-time construct which is faster and does not require RTTI.<dl>
       <dd><b>Virtual member functions</b></dl>
      <p>Through <b><!--del_lnk--> virtual member functions</b>, different objects that share a common base class may all support an operation in different ways. The member functions implemented by the derived class are said to <!--del_lnk--> override the same member functions of the base class. In contrast with function overloading, the parameters for a given member function are always exactly the same number and type. Only the type of the object for which this method is called varies. In addition to standard member functions, operator overloads and destructors can also be virtual.<p>By virtue of inherited objects being polymorphic, it may not be possible for the compiler to determine the type of the object at compile time. The decision is therefore put off until runtime, and is called <!--del_lnk--> dynamic dispatch. In this way, the most specific implementation of the function is called, according to the actual run-time type of the object. In C++, this is commonly done using <!--del_lnk--> virtual function tables. This may sometimes be bypassed by prepending a <!--del_lnk--> fully qualified class name before the function call, but calls to virtual functions are in general always resolved at run time.<dl>
       <dd><b>An example</b></dl><pre>
#include &lt;iostream&gt;

class Bird                 // the &quot;generic&quot; base class
{
public:
  virtual void OutputName() {std::cout &lt;&lt; &quot;a bird&quot;;}
  virtual ~Bird() {}
};

class Swan : public Bird   // Swan derives from Bird
{ 
public:
  void OutputName() {std::cout &lt;&lt; &quot;a swan&quot;;} // overrides virtual function
};

int main()
{
  Bird* myBird = new Swan; // Declares a pointer to a generic Bird,
                           // and sets it pointing to a newly created Swan.

  myBird-&gt;OutputName();    // This will output &quot;a swan&quot;, not &quot;a bird&quot;.

  delete myBird;

  return 0;
}
</pre><p>This example program makes use of virtual functions, polymorphism, and inheritance to derive new, more specific objects from a base class. In this case, the base class is a <code>Bird</code>, and the more specific <code>Swan</code> is made.<br />
      <p><a id="Problems_and_controversies" name="Problems_and_controversies"></a><h2> <span class="mw-headline">Problems and controversies</span></h2>
      <p>C++ has been the subject of debate. Traditionally, C++ compilers have had a range of problems. The C++ standard does not cover implementation of <!--del_lnk--> name mangling, <!--del_lnk--> exception handling, and other implementation-specific features, making <!--del_lnk--> object code produced by different <!--del_lnk--> compilers incompatible; there are, however, 3rd-party standards for particular machines or <!--del_lnk--> operating systems which attempt to standardize compilers on those platforms (for example C++ ABI); some compilers adopt a secondary standard for these items.<p>For many years, different C++ compilers implemented the C++ language to different levels of compliance to the standard, and their implementations varied widely in some areas such as <!--del_lnk--> partial template specialization. Recent releases of most popular C++ compilers support almost all of the C++ 1998 standard . One particular point of contention is the <tt>export</tt> keyword, intended to allow template definitions to be separated from their declarations. The first compiler to implement <tt>export</tt> was Comeau C++, in early 2003 (5 years after the release of the standard); in 2004, beta compiler of <!--del_lnk--> Borland C++ Builder X was also released with <tt>export</tt>. Both of these compilers are based on the <!--del_lnk--> EDG C++ front end. It should also be noted that many C++ books provide example code for implementing the keyword <tt>export</tt> (for example, <i>Beginning ANSI C++</i> by Ivor Horton) which will not compile, but there is no reference to the problem with the keyword <tt>export</tt> mentioned. Other compilers such as <!--del_lnk--> GCC do not support it at all. <!--del_lnk--> Herb Sutter, secretary of the C++ standards committee, recommended that <tt>export</tt> be removed from future versions of the C++ standard <!--del_lnk--> , but finally the decision was made to leave it in the C++ standard .<p>Modern critics of the language raise several points. First, since C++ is based on and largely compatible with C, it inherits most of the <!--del_lnk--> criticisms levelled at that language. Taken as a whole C++ has a large feature set, including all of C, plus a large set of its own additions, in part leading to criticisms of being a &quot;bloated&quot; and complicated language, especially for <!--del_lnk--> embedded systems due to features such as exceptions and <!--del_lnk--> RTTI which add to code size. The <!--del_lnk--> Embedded C++ standard was specified to deal with part of this, but it received criticism for leaving out useful parts of the language that incur no runtime penalty.<!--del_lnk-->  Because of its large featureset it can be quite difficult to fully master, leading to programmers often bringing unnecessarily advanced or complicated solutions to simple problems, and it is relatively difficult to write a good C++ <!--del_lnk--> parser with modern algorithms (see <!--del_lnk--> ). This is partly because the C++ grammar is not <!--del_lnk--> LALR(1). Because of this, there are very few tools for analyzing or performing non-trivial transformations (e.g., <!--del_lnk--> refactoring) of existing code.<p>C++ is also sometimes compared unfavorably with single-paradigm object-oriented languages such as Java, on the basis that it allows programmers to &quot;mix and match&quot; <!--del_lnk--> object-oriented and <!--del_lnk--> procedural programming, rather than strictly enforcing a single paradigm. This is part of <!--del_lnk--> a wider debate on the relative merits of the two programming styles.<p><a id="See_also" name="See_also"></a><div class="printfooter"> Retrieved from &quot;<!--del_lnk--> http://en.wikipedia.org/wiki/C%2B%2B&quot;</div>
      <!-- end content -->
      <div class="visualClear">
      </div>
     </div>
    </div>
   </div>
   <!-- end of the left (by default at least) column -->
   <div class="visualClear">
   </div>
   <div id="footer">
    <div class="center"> This reference article is mainly selected from the English Wikipedia with only minor checks and changes (see www.wikipedia.org for details of authors and sources) and is available under the <nobr><a href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm">GNU Free Documentation License</a></nobr>. See also our <b><a href="../../disclaimer.htm">Disclaimer</a></b>. </div>
   </div>
   <script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
  </div>
  
 </body>
</html>
