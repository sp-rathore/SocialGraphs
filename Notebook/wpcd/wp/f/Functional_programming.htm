<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html dir="ltr" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
  <meta content="Functional programming,2006,APL programming language,Academic,Alonzo Church,Anamorphism,Antiderivative,Array programming,Arthur Whitney,Association for Computing Machinery,August 28" name="keywords" />
  <link href="../../favicon.ico" rel="shortcut icon" />
  <link href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm" rel="copyright" />
  <title>Functional programming</title>
  <style media="screen,projection" type="text/css">/*<![CDATA[*/ @import "../../css/wp-monobook-main.css"; /*]]>*/</style>
  <link href="../../css/wp-commonPrint.css" media="print" rel="stylesheet" type="text/css" />
  <!--[if lt IE 5.5000]><style type="text/css">@import "../../css/IE50Fixes.css";</style><![endif]-->
  <!--[if IE 5.5000]><style type="text/css">@import "../../css/IE55Fixes.css";</style><![endif]-->
  <!--[if IE 6]><style type="text/css">@import "../../css/IE60Fixes.css";</style><![endif]-->
  <!--[if IE 7]><style type="text/css">@import "../../css/IE70Fixes.css";</style><![endif]-->
  <!--[if lt IE 7]><script type="text/javascript" src="../../js/IEFixes.js"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
  <script type="text/javascript">
			var skin = "monobook";
			var stylepath = "/skins-1.5";

			var wgArticlePath = "/wiki/$1";
			var wgScriptPath = "/w";
			var wgServer = "http://en.wikipedia.org";
                        
			var wgCanonicalNamespace = "";
			var wgNamespaceNumber = 0;
			var wgPageName = "Functional_programming";
			var wgTitle = "Functional programming";
			var wgArticleId = 10933;
			var wgIsArticle = true;
                        
			var wgUserName = null;
			var wgUserLanguage = "en";
			var wgContentLanguage = "en";
		</script>
  <script src="../../js/wikibits.js" type="text/javascript"><!-- wikibits js --></script>
  <script src="../../js/wp.js" type="text/javascript"><!-- site js --></script>
  <style type="text/css">/*<![CDATA[*/
@import "../../css/wp-common.css";
@import "../../css/wp-monobook.css";
@import "../../css/wp.css";
/*]]>*/</style>
  <!-- Head Scripts -->
 </head>
 <body class="mediawiki ns-0 ltr page-Functional_programming">
  <div id="globalWrapper">
   <div id="column-content">
    <div id="content"><a id="top" name="top"></a><h1 class="firstHeading">Functional programming</h1>
     <div id="bodyContent">
      <h3 id="siteSub"><a href="../../index.htm">2007 Schools Wikipedia Selection</a>. Related subjects: <a href="../index/subject.IT.Computer_Programming.htm">Computer Programming</a></h3>
      <!-- start content -->
      <p><b>Functional programming</b> is a <!--del_lnk--> programming paradigm that conceives <!--del_lnk--> computation as the evaluation of <!--del_lnk--> mathematical functions and avoids state and <!--del_lnk--> mutable data. Functional programming emphasizes the application of functions, in contrast with <a href="../../wp/i/Imperative_programming.htm" title="Imperative programming">imperative programming</a>, which emphasizes changes in <!--del_lnk--> state and the execution of sequential commands.<p>A broader conception of functional programming simply defines a set of common concerns and themes rather than a list of distinctions from other paradigms. Often considered important are <!--del_lnk--> higher-order and <!--del_lnk--> first-class functions, <!--del_lnk--> closures, and <!--del_lnk--> recursion. Other common features of functional programming languages are <!--del_lnk--> continuations, <!--del_lnk--> Hindley-Milner type inference systems, non-strict evaluation (including, but not limited to, &quot;<!--del_lnk--> laziness&quot;), and <!--del_lnk--> monads.<p>Functional programming languages, especially &quot;purely functional&quot; ones, have largely been emphasized in <!--del_lnk--> academia rather than in commercial software development. However, notable functional programming languages used in industry and commercial applications include <!--del_lnk--> Erlang (concurrent applications), <!--del_lnk--> R (statistics), <!--del_lnk--> Mathematica (symbolic math), <!--del_lnk--> J and <!--del_lnk--> K (financial analysis), and <!--del_lnk--> domain-specific programming languages like <!--del_lnk--> XSLT. Important influences on functional programming have been the <!--del_lnk--> lambda calculus, the <!--del_lnk--> APL programming language, the <!--del_lnk--> Lisp programming language, and more recently the <!--del_lnk--> Haskell programming language.<p>
       <script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script><a id="History" name="History"></a><h2> <span class="mw-headline">History</span></h2>
      <p><!--del_lnk--> Lambda calculus, invented by <!--del_lnk--> Alonzo Church in the 1930s, provides a theoretical framework for describing functions and their evaluation. Though it is a mathematical abstraction rather than a programming language, lambda calculus forms the basis of almost all functional programming languages today.<p><!--del_lnk--> Combinatory logic is an equivalent theoretical foundation, developed by <!--del_lnk--> Moses Sch&ouml;nfinkel and <!--del_lnk--> Haskell Curry. It was originally developed to achieve a larger goal: a clearer approach to the foundations of mathematics. Combinatory logic, which is commonly perceived as more abstract than <!--del_lnk--> lambda calculus, preceded <!--del_lnk--> lambda-calculus in invention.<p>The first computer-based functional programming language was <!--del_lnk--> Information Processing Language (IPL), developed by Newell, Shaw, and Simon at <!--del_lnk--> RAND Corporation for the <!--del_lnk--> JOHNNIAC computer in the mid-1950s. An early functional-flavored programming language was <!--del_lnk--> LISP (now mixed-case &quot;Lisp&quot;), developed by <!--del_lnk--> John McCarthy while at <!--del_lnk--> MIT for the <!--del_lnk--> IBM 700/7000 series scientific computers in the late 1950s. LISP introduced many of the features now found in modern functional programming languages, though LISP is technically a multi-paradigm language. <a href="../../wp/s/Scheme_programming_language.htm" title="Scheme programming language">Scheme</a> and <!--del_lnk--> Dylan were later attempts to simplify and improve LISP.<p><!--del_lnk--> Kenneth E. Iverson developed the <!--del_lnk--> APL programming language in the early 1960s, described in his 1962 book &quot;A Programming Language.&quot; APL was the primary influence on <!--del_lnk--> John Backus&#39;s <!--del_lnk--> FP programming language. In the early 1990s, Iverson and <!--del_lnk--> Roger Hui created a successor to APL, the <!--del_lnk--> J programming language. In the mid 1990s, <!--del_lnk--> Arthur Whitney, who had previously worked with Iverson, created the <!--del_lnk--> K programming language, which is used commercially in financial industries.<p><!--del_lnk--> John Backus presented the <!--del_lnk--> FP programming language in his 1977 <!--del_lnk--> Turing Award lecture <!--del_lnk--> Can Programming Be Liberated From the von Neumann Style? A Functional Style and its Algebra of Programs. He defines functional programs as being built up in a hierarchical way by means of &quot;combining forms&quot; that allow an &quot;algebra of programs&quot;; in modern language, this means that functional program follow the <!--del_lnk--> principle of compositionality. Backus&#39;s paper popularized research into functional programming, though it emphasized <!--del_lnk--> function-level programming rather than the lambda-calculus style which has come to be associated with functional programming.<p>In the 1970s the <!--del_lnk--> ML programming language was created by <!--del_lnk--> Robin Milner at the <!--del_lnk--> University of Edinburgh, and <!--del_lnk--> David Turner developed the language <!--del_lnk--> Miranda at the <!--del_lnk--> University of Kent. ML eventually developed into <!--del_lnk--> several dialects, the most common of which are now <!--del_lnk--> Objective Caml and <!--del_lnk--> Standard ML. The <!--del_lnk--> Haskell programming language was released in the late 1980s in an attempt to gather together many ideas in functional programming research.<p><a id="Concepts" name="Concepts"></a><h2> <span class="mw-headline">Concepts</span></h2>
      <p>A number of concepts and paradigms are specific to functional programming, and generally foreign to imperative programming (including <!--del_lnk--> object oriented programming). However, programming languages are often hybrids of several programming paradigms so programmers using &quot;mostly imperative&quot; languages may have utilized some of these concepts.<p><a id="Higher-order_functions" name="Higher-order_functions"></a><h3> <span class="mw-headline">Higher-order functions</span></h3>
      <p>Functional programming uses the notion of <!--del_lnk--> higher-order functions. Functions are higher-order when they can take other functions as arguments, and/or return functions as results. (The <!--del_lnk--> derivative and <!--del_lnk--> antiderivative in <a href="../../wp/c/Calculus.htm" title="Calculus">calculus</a> are mathematical examples of functions that map a function to another function.)<p>Higher-order functions are closely related to <!--del_lnk--> first-class functions, in that higher-order functions and first-class functions both allow functions as arguments and results of other functions. The distinction between the two is subtle: &quot;higher-order&quot; describes a mathematical concept of functions that operate on other functions, while &quot;first-class&quot; is a computer science term that describes programming language entities that have no restriction on their use (thus first-class functions can appear anywhere in the program that other first-class entities like numbers can, including as arguments to other functions and as their return values).<p>Higher-order functions enable <!--del_lnk--> currying, a technique in which a function is applied to its arguments one at a time, with each application returning a new (higher-order) function that accepts the next argument.<p><a id="Pure_functions" name="Pure_functions"></a><h3> <span class="mw-headline">Pure functions</span></h3>
      <p><!--del_lnk--> Purely functional programs have no <!--del_lnk--> side-effects. Not all functional programs or functional programming languages are purely functional. Since pure functions do not modify state, no data may be changed by parallel function calls. Pure functions are therefore <!--del_lnk--> thread-safe, which allows languages to use <!--del_lnk--> call-by-future evaluation. The lack of side-effects allows some languages, such as <!--del_lnk--> Haskell, to use <!--del_lnk--> call-by-need evaluation.<p>&quot;Pure&quot; functional programming languages typically enforce <!--del_lnk--> referential transparency, which is the notion that &#39;equals can be substituted for equals&#39;: if two expressions have &quot;equal&quot; values (for some notion of equality), then one can be substituted for the other in any larger expression without affecting the result of the computation. For example, in<pre>
y = f(x) * f(x);    
</pre><p>a compiler can factor out <code>f(x)</code> if it is pure, transforming the program to<pre>
z = f(x);   
y = z * z;       
</pre><p>and eliminating the second evaluation of the (possibly costly) call to <code>f(x)</code>. This optimization is called <!--del_lnk--> common subexpression elimination.<p>However, if a function has side effects, the function call cannot be eliminated. Consider the following program fragment:<pre>
y = random() * random();    
</pre><p>The second call to <code>random</code> cannot be eliminated, because its return value may be different from that of the first call. Similarly,<pre>
y = printf(&quot;x&quot;) * printf(&quot;x&quot;);      
</pre><p>cannot be optimized away; even if <code>printf</code> returns the same value both times, failing to make the second call would result in different program output.<p>Most compilers for imperative programming languages do not perform common subexpression elimination for function calls, because they do not track whether a function is pure. It is possible for an advanced compiler to infer whether a local function has effects and optimize accordingly; however, most pre-compiled libraries do not expose this information, preventing calls to external functions from being optimized away. Some compilers, such as <!--del_lnk--> gcc, add extra keywords for a programmer to explicitly mark pure functions so that this optimization can be performed.<p><a id="Recursion" name="Recursion"></a><h3> <span class="mw-headline">Recursion</span></h3>
      <p><!--del_lnk--> Iteration (looping) in functional languages is usually accomplished via <!--del_lnk--> recursion. <!--del_lnk--> Recursive functions invoke themselves, allowing an operation to be performed over and over. Recursion may require maintaining a stack, but <!--del_lnk--> tail recursion can be recognized and optimized by a compiler into the same code used to implement iteration in imperative languages. The <a href="../../wp/s/Scheme_programming_language.htm" title="Scheme programming language">Scheme programming language</a> standard requires implementations to recognize and optimize tail recursion.<p>Common patterns of recursion can be factored out using higher order functions, <!--del_lnk--> catamorphisms and <!--del_lnk--> anamorphisms (or &quot;folds&quot; and &quot;unfolds&quot;) being the most obvious examples. Such higher order functions play a role analogous to built-in control structures such as loops in imperative languages.<p><a id="Functional_programming_in_non-functional_languages" name="Functional_programming_in_non-functional_languages"></a><h3> <span class="mw-headline">Functional programming in non-functional languages</span></h3>
      <p>It is possible to employ a functional style of programming in languages that are not traditionally considered functional languages. Some non-functional languages have borrowed features such as <!--del_lnk--> lambda functions, <!--del_lnk--> higher-order functions, and <!--del_lnk--> list comprehensions from functional programming languages. This makes it easier to adopt a functional style when using these languages. Functional constructs such as higher-order functions and lazy lists can be obtained in C++ via libraries. In C one can use function pointers to get some of the effects of higher-order functions, for example one can implement the common function <!--del_lnk--> map using function pointers. Widespread declarative domain specific languages like <!--del_lnk--> SQL and <!--del_lnk--> Lex/<!--del_lnk--> Yacc, while not <!--del_lnk--> Turing-complete, use some elements of functional programming, especially in eschewing mutable values.<p><a id="Comparison_of_functional_and_imperative_programming" name="Comparison_of_functional_and_imperative_programming"></a><h2> <span class="mw-headline">Comparison of functional and imperative programming</span></h2>
      <p>Functional programming is very different from <a href="../../wp/i/Imperative_programming.htm" title="Imperative programming">imperative programming</a>. The most significant differences stem from the fact that functional programming avoids side effects, which are used in imperative programming to implement state and I/O. <i>Pure functional programming</i> disallows side effects completely. Disallowing side effects provides for <!--del_lnk--> referential transparency, which makes it easier to verify, optimize, and parallelize programs, and easier to write automated tools to perform those tasks.<p>Higher order functions are rarely used in older imperative programming. Where a traditional imperative program might use a loop to traverse a list, a functional style would often use a higher-order function, map, that takes as argument a function and a list, applies the function to each element of the list, and returns a list of the results.<p><a id="Simulating_state" name="Simulating_state"></a><h3> <span class="mw-headline">Simulating state</span></h3>
      <p>There are tasks&mdash;for example, maintaining a bank account balance&mdash;that often seem most naturally implemented with state. Pure functional programming performs these tasks, and I/O tasks such as accepting user input and printing to the screen, in a different way.<p>The pure functional programming language Haskell implements them using <!--del_lnk--> monads, derived from <!--del_lnk--> category theory in mathematics. Monads are extremely powerful and offer an intuitive way to model state (and other side effects such as IO) in an imperative manner without losing purity. While existing monads are easy to use, many find it difficult to understand how to define new monads (which is sometimes needed for certain types of libraries).<p>Alternative methods such as <!--del_lnk--> Hoare logic have been developed to track side effects in programs. Some modern research languages use <!--del_lnk--> effect systems to make explicit the presence of side effects.<p><a id="Efficiency_issues" name="Efficiency_issues"></a><h3> <span class="mw-headline">Efficiency issues</span></h3>
      <p>Functional programming languages have automatic memory management with garbage collection, in contrast to older imperative languages like C and Pascal which use explicit memory management. Functional programming languages have been perceived as less efficient in their use of CPU and memory than those languages. However, many modern imperative languages such as Java, Perl, Python, and Ruby also perform automatic memory management.<p>Functional programming languages have become more efficient over the years. For programs which perform intensive numerical computations, functional languages such as <!--del_lnk--> OCaml and <!--del_lnk--> Clean are similar in speed to <!--del_lnk--> C. For programs that handle large matrices and multidimensional databases, <!--del_lnk--> array functional languages (such as <!--del_lnk--> J and <!--del_lnk--> K) were designed with speed optimization in mind. Despite purely functional languages having a reputation for being slower, any imperative algorithm is expressible in these languages with a logarithmic slowdown in the worst case. Moreover, the immutability of data can in many cases lead to greater execution efficiency owing to the compiler making assumptions that are unsafe in an imperative language.<p><a id="Coding_styles" name="Coding_styles"></a><h3> <span class="mw-headline">Coding styles</span></h3>
      <p>Imperative programs tend to emphasize the series of steps taken by a program in carrying out an action, while functional programs tend to emphasize the composition and arrangement of functions, often without specifying explicit <i>steps</i>. A simple example of two solutions to the same programming goal (using the same multi-paradigm language <!--del_lnk--> Python) illustrates this.<pre>
# imperative style
target = []               # create empty list
for item in source_list:  # iterate over each thing in source
    trans1 = G(item)      # transform the item with the G() function
    trans2 = F(trans1)    # second transform with the F() function
    target.append(trans2) # add transformed item to target
</pre><p>A functional version has a different feel to it:<pre>
# functional style
def compose2(F, G):       # FP-oriented languages often have standard compose()
    def C(item):          # here we create utility-function for composition
        return F(G(item))
    return C
target = map(compose2(F,G), source_list)
</pre> <pre>
# More compact examples of the functional paradigm in Python:
target =  map(lambda x: F(G(x)), source_list) # uses a lambda form with map
# or:
target = [F(G(item)) for item in source_list] # a list comprehension
</pre><p>In contrast to the imperative style that describes the steps involved in building <code>target</code>, the functional style describes the mathematical relationship between <code>source_list</code> and <code>target</code>.<p><a id="See_also" name="See_also"></a><div class="printfooter"> Retrieved from &quot;<!--del_lnk--> http://en.wikipedia.org/wiki/Functional_programming&quot;</div>
      <!-- end content -->
      <div class="visualClear">
      </div>
     </div>
    </div>
   </div>
   <!-- end of the left (by default at least) column -->
   <div class="visualClear">
   </div>
   <div id="footer">
    <div class="center"> This reference article is mainly selected from the English Wikipedia with only minor checks and changes (see www.wikipedia.org for details of authors and sources) and is available under the <nobr><a href="../../wp/w/Wikipedia_Text_of_the_GNU_Free_Documentation_License.htm">GNU Free Documentation License</a></nobr>. See also our <b><a href="../../disclaimer.htm">Disclaimer</a></b>. </div>
   </div>
   <script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
  </div>
  
 </body>
</html>
